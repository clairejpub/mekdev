
/*
 * EyeDB Version 2.7.13 Copyright (c) 1995-2006 SYSRA
 *
 * File 'mekano.h'
 *
 * Package Name 'mekano'
 *
 * Generated by eyedbodl at Mon Apr 28 17:01:31 2008
 *
 * ---------------------------------------------------
 * -------------- DO NOT EDIT THIS CODE --------------
 * ---------------------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#ifndef _eyedb_mekano_
#define _eyedb_mekano_

namespace mekano {

class Root;
class Bank;
class Clone;
class Read;
class Sequence;
class ReadPosition;
class ContinuousSequence;
class Contig;
class Cut;
class Metacontig;
class Region;
class LinkCount;
class LinkCounts;
class Supercontig;
class SupercontigPair;
class Calculated;
class Parameters;
class GroupName;
class SupercontigSet;
class Group;
class StageType;
class Stage;
class Algorithm;
class MatchSide;
class Match;


class mekano {

 public:
  mekano(int &argc, char *argv[]) {
    eyedb::init(argc, argv);
    init();
  }

  ~mekano() {
    release();
    eyedb::release();
  }

  static void init();
  static void release();
  static eyedb::Status updateSchema(eyedb::Database *db);
  static eyedb::Status updateSchema(eyedb::Schema *m);
};

class mekanoDatabase : public eyedb::Database {

 public:
  mekanoDatabase(const char *dbname, const char *_dbmdb_str = 0) : eyedb::Database(dbname, _dbmdb_str) {}
  mekanoDatabase(eyedb::Connection *conn, const char *dbname, const char *_dbmdb_str, eyedb::Database::OpenFlag, const char *user = 0, const char *passwd = 0);
  mekanoDatabase(eyedb::Connection *conn, const char *dbname, eyedb::Database::OpenFlag, const char *user = 0, const char *passwd = 0);
  mekanoDatabase(const char *dbname, int _dbid, const char *_dbmdb_str = 0) : eyedb::Database(dbname, _dbid, _dbmdb_str) {}
  mekanoDatabase(int _dbid, const char *_dbmdb_str = 0) : eyedb::Database(_dbid, _dbmdb_str) {}
  eyedb::Status open(eyedb::Connection *, eyedb::Database::OpenFlag, const char *user = 0, const char *passwd = 0);
  eyedb::Status open(eyedb::Connection *, eyedb::Database::OpenFlag, const eyedb::OpenHints *hints, const char *user = 0, const char *passwd = 0);
  static void setConsApp(eyedb::Database *);

  static Root *asRoot(eyedb::Object *);
  static const Root *asRoot(const eyedb::Object *);
  static eyedb::Status checkSchema(eyedb::Schema *);
  static eyedb::Bool getDynamicGetErrorPolicy();
  static eyedb::Bool getDynamicSetErrorPolicy();
  static void setDynamicGetErrorPolicy(eyedb::Bool policy);
  static void setDynamicSetErrorPolicy(eyedb::Bool policy);
};

class Root : public eyedb::Struct {

 public:
  Root(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Root(const Root& x);

  virtual eyedb::Object *clone() const {return _clone();};
  virtual eyedb::Object *_clone() const {return new Root(*this);};

  Root& operator=(const Root& x);

  virtual Root *asRoot() {return this;}
  virtual const Root *asRoot() const {return this;}
  virtual Bank *asBank() {return (Bank *)0;}
  virtual const Bank *asBank() const {return (const Bank *)0;}
  virtual Clone *asClone() {return (Clone *)0;}
  virtual const Clone *asClone() const {return (const Clone *)0;}
  virtual Read *asRead() {return (Read *)0;}
  virtual const Read *asRead() const {return (const Read *)0;}
  virtual Sequence *asSequence() {return (Sequence *)0;}
  virtual const Sequence *asSequence() const {return (const Sequence *)0;}
  virtual ReadPosition *asReadPosition() {return (ReadPosition *)0;}
  virtual const ReadPosition *asReadPosition() const {return (const ReadPosition *)0;}
  virtual ContinuousSequence *asContinuousSequence() {return (ContinuousSequence *)0;}
  virtual const ContinuousSequence *asContinuousSequence() const {return (const ContinuousSequence *)0;}
  virtual Contig *asContig() {return (Contig *)0;}
  virtual const Contig *asContig() const {return (const Contig *)0;}
  virtual Cut *asCut() {return (Cut *)0;}
  virtual const Cut *asCut() const {return (const Cut *)0;}
  virtual Metacontig *asMetacontig() {return (Metacontig *)0;}
  virtual const Metacontig *asMetacontig() const {return (const Metacontig *)0;}
  virtual Region *asRegion() {return (Region *)0;}
  virtual const Region *asRegion() const {return (const Region *)0;}
  virtual LinkCount *asLinkCount() {return (LinkCount *)0;}
  virtual const LinkCount *asLinkCount() const {return (const LinkCount *)0;}
  virtual LinkCounts *asLinkCounts() {return (LinkCounts *)0;}
  virtual const LinkCounts *asLinkCounts() const {return (const LinkCounts *)0;}
  virtual Supercontig *asSupercontig() {return (Supercontig *)0;}
  virtual const Supercontig *asSupercontig() const {return (const Supercontig *)0;}
  virtual SupercontigPair *asSupercontigPair() {return (SupercontigPair *)0;}
  virtual const SupercontigPair *asSupercontigPair() const {return (const SupercontigPair *)0;}
  virtual Calculated *asCalculated() {return (Calculated *)0;}
  virtual const Calculated *asCalculated() const {return (const Calculated *)0;}
  virtual Parameters *asParameters() {return (Parameters *)0;}
  virtual const Parameters *asParameters() const {return (const Parameters *)0;}
  virtual GroupName *asGroupName() {return (GroupName *)0;}
  virtual const GroupName *asGroupName() const {return (const GroupName *)0;}
  virtual SupercontigSet *asSupercontigSet() {return (SupercontigSet *)0;}
  virtual const SupercontigSet *asSupercontigSet() const {return (const SupercontigSet *)0;}
  virtual Group *asGroup() {return (Group *)0;}
  virtual const Group *asGroup() const {return (const Group *)0;}
  virtual StageType *asStageType() {return (StageType *)0;}
  virtual const StageType *asStageType() const {return (const StageType *)0;}
  virtual Stage *asStage() {return (Stage *)0;}
  virtual const Stage *asStage() const {return (const Stage *)0;}
  virtual Algorithm *asAlgorithm() {return (Algorithm *)0;}
  virtual const Algorithm *asAlgorithm() const {return (const Algorithm *)0;}
  virtual MatchSide *asMatchSide() {return (MatchSide *)0;}
  virtual const MatchSide *asMatchSide() const {return (const MatchSide *)0;}
  virtual Match *asMatch() {return (Match *)0;}
  virtual const Match *asMatch() const {return (const Match *)0;}
  virtual ~Root() {garbageRealize();}

 protected:
  Root(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : eyedb::Struct(_db, _dataspace) {}
  Root(const eyedb::Struct *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}
  Root(const Root *x, eyedb::Bool share, int) : eyedb::Struct(x, share) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Root(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Root(const Root *, eyedb::Bool = eyedb::False);
  Root(const eyedb::Class *, eyedb::Data);
};

struct Bank:Root
{
	static char const*_classname(){return"Bank";}
	static Bank*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asBank();return 0;}

 public:
  Bank(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Bank(const Bank& x);

  virtual eyedb::Object *_clone() const {return new Bank(*this);};

  Bank& operator=(const Bank& x);

  virtual Bank *asBank() {return this;}
  virtual const Bank *asBank() const {return this;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status length(eyedblib::int32 );
  eyedblib::int32 length(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Bank() {garbageRealize();}

 protected:
  Bank(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Bank(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Bank(const Bank *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Bank(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Bank(const Bank *, eyedb::Bool = eyedb::False);
  Bank(const eyedb::Class *, eyedb::Data);
};

struct Clone:Root
{
	static char const*_classname(){return"Clone";}
	static Clone*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asClone();return 0;}

 public:
  Clone(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Clone(const Clone& x);

  virtual eyedb::Object *_clone() const {return new Clone(*this);};

  Clone& operator=(const Clone& x);

  virtual Clone *asClone() {return this;}
  virtual const Clone *asClone() const {return this;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status bank(Bank*);
  Bank*bank(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Bank*bank(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid bank_oid(eyedb::Status * = 0) const;
  eyedb::Status bank_oid(const eyedb::Oid &);
  virtual ~Clone() {garbageRealize();}

 protected:
  Clone(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Clone(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Clone(const Clone *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Clone(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Clone(const Clone *, eyedb::Bool = eyedb::False);
  Clone(const eyedb::Class *, eyedb::Data);
};

struct Read:Root
{
	static char const*_classname(){return"Read";}
	static Read*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asRead();return 0;}

 public:
  Read(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Read(const Read& x);

  virtual eyedb::Object *_clone() const {return new Read(*this);};

  Read& operator=(const Read& x);

  virtual Read *asRead() {return this;}
  virtual const Read *asRead() const {return this;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status clone(Clone*);
  Clone*clone(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Clone*clone(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid clone_oid(eyedb::Status * = 0) const;
  eyedb::Status clone_oid(const eyedb::Oid &);

  eyedb::Status length(eyedblib::int32 );
  eyedblib::int32 length(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Read() {garbageRealize();}

 protected:
  Read(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Read(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Read(const Read *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Read(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Read(const Read *, eyedb::Bool = eyedb::False);
  Read(const eyedb::Class *, eyedb::Data);
};

struct Sequence:Root
{
	static char const*_classname(){return"Sequence";}
	static Sequence*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asSequence();return 0;}

 public:
  Sequence(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Sequence(const Sequence& x);

  virtual eyedb::Object *_clone() const {return new Sequence(*this);};

  Sequence& operator=(const Sequence& x);

  virtual Sequence *asSequence() {return this;}
  virtual const Sequence *asSequence() const {return this;}
  virtual ContinuousSequence *asContinuousSequence() {return (ContinuousSequence *)0;}
  virtual const ContinuousSequence *asContinuousSequence() const {return (const ContinuousSequence *)0;}
  virtual Contig *asContig() {return (Contig *)0;}
  virtual const Contig *asContig() const {return (const Contig *)0;}
  virtual Metacontig *asMetacontig() {return (Metacontig *)0;}
  virtual const Metacontig *asMetacontig() const {return (const Metacontig *)0;}
  virtual Supercontig *asSupercontig() {return (Supercontig *)0;}
  virtual const Supercontig *asSupercontig() const {return (const Supercontig *)0;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status length(eyedblib::int32 );
  eyedblib::int32 length(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status created_in(Stage*);
  Stage*created_in(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Stage*created_in(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid created_in_oid(eyedb::Status * = 0) const;
  eyedb::Status created_in_oid(const eyedb::Oid &);
  virtual ~Sequence() {garbageRealize();}

 protected:
  Sequence(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Sequence(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Sequence(const Sequence *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Sequence(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Sequence(const Sequence *, eyedb::Bool = eyedb::False);
  Sequence(const eyedb::Class *, eyedb::Data);
};

struct ReadPosition:Root
{
	static char const*_classname(){return"ReadPosition";}
	static ReadPosition*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asReadPosition();return 0;}

 public:
  ReadPosition(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ReadPosition(const ReadPosition& x);

  virtual eyedb::Object *_clone() const {return new ReadPosition(*this);};

  ReadPosition& operator=(const ReadPosition& x);

  virtual ReadPosition *asReadPosition() {return this;}
  virtual const ReadPosition *asReadPosition() const {return this;}

  eyedb::Status read(Read*);
  Read*read(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Read*read(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid read_oid(eyedb::Status * = 0) const;
  eyedb::Status read_oid(const eyedb::Oid &);

  eyedb::Status start_on_read(eyedblib::int32 );
  eyedblib::int32 start_on_read(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status start_on_contig(eyedblib::int32 );
  eyedblib::int32 start_on_contig(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status length(eyedblib::int32 );
  eyedblib::int32 length(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status forward(eyedb::Bool , eyedb::Bool _check_value = eyedb::True);
  eyedb::Bool forward(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~ReadPosition() {garbageRealize();}

 protected:
  ReadPosition(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  ReadPosition(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  ReadPosition(const ReadPosition *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ReadPosition(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ReadPosition(const ReadPosition *, eyedb::Bool = eyedb::False);
  ReadPosition(const eyedb::Class *, eyedb::Data);
};

struct ContinuousSequence:Sequence
{
	static char const*_classname(){return"ContinuousSequence";}
	static ContinuousSequence*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asContinuousSequence();return 0;}

 public:
  ContinuousSequence(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  ContinuousSequence(const ContinuousSequence& x);

  virtual eyedb::Object *_clone() const {return new ContinuousSequence(*this);};

  ContinuousSequence& operator=(const ContinuousSequence& x);

  virtual ContinuousSequence *asContinuousSequence() {return this;}
  virtual const ContinuousSequence *asContinuousSequence() const {return this;}
  virtual Contig *asContig() {return (Contig *)0;}
  virtual const Contig *asContig() const {return (const Contig *)0;}
  virtual Metacontig *asMetacontig() {return (Metacontig *)0;}
  virtual const Metacontig *asMetacontig() const {return (const Metacontig *)0;}
  virtual ~ContinuousSequence() {garbageRealize();}

 protected:
  ContinuousSequence(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Sequence(_db, _dataspace, 1) {}
  ContinuousSequence(const eyedb::Struct *x, eyedb::Bool share, int) : Sequence(x, share, 1) {}
  ContinuousSequence(const ContinuousSequence *x, eyedb::Bool share, int) : Sequence(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  ContinuousSequence(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  ContinuousSequence(const ContinuousSequence *, eyedb::Bool = eyedb::False);
  ContinuousSequence(const eyedb::Class *, eyedb::Data);
};

struct Contig:ContinuousSequence
{
	static char const*_classname(){return"Contig";}
	static Contig*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asContig();return 0;}

 public:
  Contig(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Contig(const Contig& x);

  virtual eyedb::Object *_clone() const {return new Contig(*this);};

  Contig& operator=(const Contig& x);

  virtual Contig *asContig() {return this;}
  virtual const Contig *asContig() const {return this;}

  eyedb::Status reads(unsigned int a0, ReadPosition*);
  eyedb::Status reads_cnt(unsigned int a0);
  ReadPosition*reads(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ReadPosition*reads(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int reads_cnt(eyedb::Status * = 0) const;

  eyedb::Status consensus(const std::string &);
  eyedb::Status consensus(unsigned int a0, char );
  std::string consensus(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char consensus(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Contig() {garbageRealize();}

 protected:
  Contig(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : ContinuousSequence(_db, _dataspace, 1) {}
  Contig(const eyedb::Struct *x, eyedb::Bool share, int) : ContinuousSequence(x, share, 1) {}
  Contig(const Contig *x, eyedb::Bool share, int) : ContinuousSequence(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Contig(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Contig(const Contig *, eyedb::Bool = eyedb::False);
  Contig(const eyedb::Class *, eyedb::Data);
};

struct Cut:Root
{
	static char const*_classname(){return"Cut";}
	static Cut*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asCut();return 0;}

 public:
  Cut(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Cut(const Cut& x);

  virtual eyedb::Object *_clone() const {return new Cut(*this);};

  Cut& operator=(const Cut& x);

  virtual Cut *asCut() {return this;}
  virtual const Cut *asCut() const {return this;}

  eyedb::Status cseq(ContinuousSequence*);
  ContinuousSequence*cseq(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ContinuousSequence*cseq(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid cseq_oid(eyedb::Status * = 0) const;
  eyedb::Status cseq_oid(const eyedb::Oid &);

  eyedb::Status start(eyedblib::int32 );
  eyedblib::int32 start(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status stop(eyedblib::int32 );
  eyedblib::int32 stop(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status source(Supercontig*);
  Supercontig*source(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Supercontig*source(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid source_oid(eyedb::Status * = 0) const;
  eyedb::Status source_oid(const eyedb::Oid &);

  eyedb::Status source_forward(eyedb::Bool , eyedb::Bool _check_value = eyedb::True);
  eyedb::Bool source_forward(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Cut() {garbageRealize();}

 protected:
  Cut(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Cut(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Cut(const Cut *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Cut(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Cut(const Cut *, eyedb::Bool = eyedb::False);
  Cut(const eyedb::Class *, eyedb::Data);
};

struct Metacontig:ContinuousSequence
{
	static char const*_classname(){return"Metacontig";}
	static Metacontig*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asMetacontig();return 0;}

 public:
  Metacontig(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Metacontig(const Metacontig& x);

  virtual eyedb::Object *_clone() const {return new Metacontig(*this);};

  Metacontig& operator=(const Metacontig& x);

  virtual Metacontig *asMetacontig() {return this;}
  virtual const Metacontig *asMetacontig() const {return this;}

  eyedb::Status cuts(unsigned int a0, Cut*);
  eyedb::Status cuts_cnt(unsigned int a0);
  Cut*cuts(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Cut*cuts(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int cuts_cnt(eyedb::Status * = 0) const;
  virtual ~Metacontig() {garbageRealize();}

 protected:
  Metacontig(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : ContinuousSequence(_db, _dataspace, 1) {}
  Metacontig(const eyedb::Struct *x, eyedb::Bool share, int) : ContinuousSequence(x, share, 1) {}
  Metacontig(const Metacontig *x, eyedb::Bool share, int) : ContinuousSequence(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Metacontig(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Metacontig(const Metacontig *, eyedb::Bool = eyedb::False);
  Metacontig(const eyedb::Class *, eyedb::Data);
};

struct Region:Root
{
	static char const*_classname(){return"Region";}
	static Region*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asRegion();return 0;}

 public:
  Region(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Region(const Region& x);

  virtual eyedb::Object *_clone() const {return new Region(*this);};

  Region& operator=(const Region& x);

  virtual Region *asRegion() {return this;}
  virtual const Region *asRegion() const {return this;}

  eyedb::Status sequence(Sequence*);
  Sequence*sequence(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Sequence*sequence(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid sequence_oid(eyedb::Status * = 0) const;
  eyedb::Status sequence_oid(const eyedb::Oid &);

  eyedb::Status gap_after(eyedblib::int32 );
  eyedblib::int32 gap_after(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status first(ContinuousSequence*);
  ContinuousSequence*first(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ContinuousSequence*first(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid first_oid(eyedb::Status * = 0) const;
  eyedb::Status first_oid(const eyedb::Oid &);

  eyedb::Status start_on_first(eyedblib::int32 );
  eyedblib::int32 start_on_first(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status last(ContinuousSequence*);
  ContinuousSequence*last(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ContinuousSequence*last(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid last_oid(eyedb::Status * = 0) const;
  eyedb::Status last_oid(const eyedb::Oid &);

  eyedb::Status stop_on_last(eyedblib::int32 );
  eyedblib::int32 stop_on_last(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Region() {garbageRealize();}

 protected:
  Region(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Region(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Region(const Region *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Region(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Region(const Region *, eyedb::Bool = eyedb::False);
  Region(const eyedb::Class *, eyedb::Data);
};

struct LinkCount:Root
{
	static char const*_classname(){return"LinkCount";}
	static LinkCount*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asLinkCount();return 0;}

 public:
  LinkCount(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  LinkCount(const LinkCount& x);

  virtual eyedb::Object *_clone() const {return new LinkCount(*this);};

  LinkCount& operator=(const LinkCount& x);

  virtual LinkCount *asLinkCount() {return this;}
  virtual const LinkCount *asLinkCount() const {return this;}

  eyedb::Status sctg(Supercontig*);
  Supercontig*sctg(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Supercontig*sctg(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid sctg_oid(eyedb::Status * = 0) const;
  eyedb::Status sctg_oid(const eyedb::Oid &);

  eyedb::Status n(eyedblib::int32 );
  eyedblib::int32 n(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~LinkCount() {garbageRealize();}

 protected:
  LinkCount(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  LinkCount(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  LinkCount(const LinkCount *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  LinkCount(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  LinkCount(const LinkCount *, eyedb::Bool = eyedb::False);
  LinkCount(const eyedb::Class *, eyedb::Data);
};

struct LinkCounts:Root
{
	static char const*_classname(){return"LinkCounts";}
	static LinkCounts*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asLinkCounts();return 0;}

 public:
  LinkCounts(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  LinkCounts(const LinkCounts& x);

  virtual eyedb::Object *_clone() const {return new LinkCounts(*this);};

  LinkCounts& operator=(const LinkCounts& x);

  virtual LinkCounts *asLinkCounts() {return this;}
  virtual const LinkCounts *asLinkCounts() const {return this;}

  eyedb::Status link_counts(unsigned int a0, LinkCount*);
  eyedb::Status link_counts_cnt(unsigned int a0);
  LinkCount*link_counts(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const LinkCount*link_counts(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int link_counts_cnt(eyedb::Status * = 0) const;
  virtual ~LinkCounts() {garbageRealize();}

 protected:
  LinkCounts(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  LinkCounts(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  LinkCounts(const LinkCounts *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  LinkCounts(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  LinkCounts(const LinkCounts *, eyedb::Bool = eyedb::False);
  LinkCounts(const eyedb::Class *, eyedb::Data);
};

struct Supercontig:Sequence
{
	static char const*_classname(){return"Supercontig";}
	static Supercontig*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asSupercontig();return 0;}

 public:
  Supercontig(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Supercontig(const Supercontig& x);

  virtual eyedb::Object *_clone() const {return new Supercontig(*this);};

  Supercontig& operator=(const Supercontig& x);

  virtual Supercontig *asSupercontig() {return this;}
  virtual const Supercontig *asSupercontig() const {return this;}

  eyedb::Status regions(unsigned int a0, Region*);
  eyedb::Status regions_cnt(unsigned int a0);
  Region*regions(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Region*regions(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int regions_cnt(eyedb::Status * = 0) const;

  eyedb::Status nb_ctg(eyedblib::int32 );
  eyedblib::int32 nb_ctg(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status nb_cseq(eyedblib::int32 );
  eyedblib::int32 nb_cseq(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status clone_links(LinkCounts*);
  LinkCounts*clone_links(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const LinkCounts*clone_links(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;

  eyedb::Status matches(LinkCounts*);
  LinkCounts*matches(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const LinkCounts*matches(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  virtual ~Supercontig() {garbageRealize();}

 protected:
  Supercontig(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Sequence(_db, _dataspace, 1) {}
  Supercontig(const eyedb::Struct *x, eyedb::Bool share, int) : Sequence(x, share, 1) {}
  Supercontig(const Supercontig *x, eyedb::Bool share, int) : Sequence(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Supercontig(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Supercontig(const Supercontig *, eyedb::Bool = eyedb::False);
  Supercontig(const eyedb::Class *, eyedb::Data);
};

struct SupercontigPair:Root
{
	static char const*_classname(){return"SupercontigPair";}
	static SupercontigPair*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asSupercontigPair();return 0;}

 public:
  SupercontigPair(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  SupercontigPair(const SupercontigPair& x);

  virtual eyedb::Object *_clone() const {return new SupercontigPair(*this);};

  SupercontigPair& operator=(const SupercontigPair& x);

  virtual SupercontigPair *asSupercontigPair() {return this;}
  virtual const SupercontigPair *asSupercontigPair() const {return this;}

  eyedb::Status sctg0(Supercontig*);
  Supercontig*sctg0(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Supercontig*sctg0(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid sctg0_oid(eyedb::Status * = 0) const;
  eyedb::Status sctg0_oid(const eyedb::Oid &);

  eyedb::Status sctg1(Supercontig*);
  Supercontig*sctg1(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Supercontig*sctg1(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid sctg1_oid(eyedb::Status * = 0) const;
  eyedb::Status sctg1_oid(const eyedb::Oid &);
  virtual ~SupercontigPair() {garbageRealize();}

 protected:
  SupercontigPair(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  SupercontigPair(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  SupercontigPair(const SupercontigPair *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  SupercontigPair(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  SupercontigPair(const SupercontigPair *, eyedb::Bool = eyedb::False);
  SupercontigPair(const eyedb::Class *, eyedb::Data);
};

struct Calculated:Root
{
	static char const*_classname(){return"Calculated";}
	static Calculated*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asCalculated();return 0;}

 public:
  Calculated(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Calculated(const Calculated& x);

  virtual eyedb::Object *_clone() const {return new Calculated(*this);};

  Calculated& operator=(const Calculated& x);

  virtual Calculated *asCalculated() {return this;}
  virtual const Calculated *asCalculated() const {return this;}

  eyedb::Status clone_links(eyedb::CollArray*);
  eyedb::CollArray*clone_links(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int clone_links_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = clone_links(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollArray*clone_links(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status setin_clone_links_at(int where, eyedb::CollBag*, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_clone_links_at(int where);
  eyedb::Status setin_clone_links_at(int where, const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_clone_links_at(const eyedb::Oid &);
  const eyedb::CollBag*clone_links_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const;
  eyedb::CollBag*clone_links_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0);
  eyedb::Oid clone_links_oidat(unsigned int ind, eyedb::Status *rs = 0) const;

  eyedb::Status matches(eyedb::CollArray*);
  eyedb::CollArray*matches(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int matches_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = matches(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollArray*matches(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status setin_matches_at(int where, eyedb::CollBag*, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_matches_at(int where);
  eyedb::Status setin_matches_at(int where, const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_matches_at(const eyedb::Oid &);
  const eyedb::CollBag*matches_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const;
  eyedb::CollBag*matches_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0);
  eyedb::Oid matches_oidat(unsigned int ind, eyedb::Status *rs = 0) const;
  virtual ~Calculated() {garbageRealize();}

 protected:
  Calculated(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Calculated(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Calculated(const Calculated *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Calculated(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Calculated(const Calculated *, eyedb::Bool = eyedb::False);
  Calculated(const eyedb::Class *, eyedb::Data);
};

struct Parameters:Root
{
	static char const*_classname(){return"Parameters";}
	static Parameters*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asParameters();return 0;}

 public:
  Parameters(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Parameters(const Parameters& x);

  virtual eyedb::Object *_clone() const {return new Parameters(*this);};

  Parameters& operator=(const Parameters& x);

  virtual Parameters *asParameters() {return this;}
  virtual const Parameters *asParameters() const {return this;}

  eyedb::Status hole_size(eyedblib::int32 );
  eyedblib::int32 hole_size(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status calculated(Calculated*);
  Calculated*calculated(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Calculated*calculated(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid calculated_oid(eyedb::Status * = 0) const;
  eyedb::Status calculated_oid(const eyedb::Oid &);
  virtual ~Parameters() {garbageRealize();}

 protected:
  Parameters(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Parameters(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Parameters(const Parameters *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Parameters(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Parameters(const Parameters *, eyedb::Bool = eyedb::False);
  Parameters(const eyedb::Class *, eyedb::Data);
};

struct GroupName:Root
{
	static char const*_classname(){return"GroupName";}
	static GroupName*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asGroupName();return 0;}

 public:
  GroupName(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  GroupName(const GroupName& x);

  virtual eyedb::Object *_clone() const {return new GroupName(*this);};

  GroupName& operator=(const GroupName& x);

  virtual GroupName *asGroupName() {return this;}
  virtual const GroupName *asGroupName() const {return this;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status comment(const std::string &);
  eyedb::Status comment(unsigned int a0, char );
  std::string comment(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char comment(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~GroupName() {garbageRealize();}

 protected:
  GroupName(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  GroupName(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  GroupName(const GroupName *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  GroupName(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  GroupName(const GroupName *, eyedb::Bool = eyedb::False);
  GroupName(const eyedb::Class *, eyedb::Data);
};

struct SupercontigSet:Root
{
	static char const*_classname(){return"SupercontigSet";}
	static SupercontigSet*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asSupercontigSet();return 0;}

 public:
  SupercontigSet(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  SupercontigSet(const SupercontigSet& x);

  virtual eyedb::Object *_clone() const {return new SupercontigSet(*this);};

  SupercontigSet& operator=(const SupercontigSet& x);

  virtual SupercontigSet *asSupercontigSet() {return this;}
  virtual const SupercontigSet *asSupercontigSet() const {return this;}

  eyedb::Status s(eyedb::CollSet*);
  eyedb::CollSet*s(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int s_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = s(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollSet*s(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status addto_s(Supercontig*, eyedb::Bool noDup = eyedb::False, const eyedb::IndexImpl * = 0);
  eyedb::Status rmvfrom_s(Supercontig*, eyedb::Bool checkFirst = eyedb::False);
  eyedb::Status addto_s(const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status rmvfrom_s(const eyedb::Oid &);
  virtual ~SupercontigSet() {garbageRealize();}

 protected:
  SupercontigSet(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  SupercontigSet(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  SupercontigSet(const SupercontigSet *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  SupercontigSet(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  SupercontigSet(const SupercontigSet *, eyedb::Bool = eyedb::False);
  SupercontigSet(const eyedb::Class *, eyedb::Data);
};

struct Group:Root
{
	static char const*_classname(){return"Group";}
	static Group*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asGroup();return 0;}

 public:
  Group(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Group(const Group& x);

  virtual eyedb::Object *_clone() const {return new Group(*this);};

  Group& operator=(const Group& x);

  virtual Group *asGroup() {return this;}
  virtual const Group *asGroup() const {return this;}

  eyedb::Status sctgs(eyedb::CollSet*);
  eyedb::CollSet*sctgs(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int sctgs_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = sctgs(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollSet*sctgs(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status addto_sctgs(Supercontig*, eyedb::Bool noDup = eyedb::False, const eyedb::IndexImpl * = 0);
  eyedb::Status rmvfrom_sctgs(Supercontig*, eyedb::Bool checkFirst = eyedb::False);
  eyedb::Status addto_sctgs(const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status rmvfrom_sctgs(const eyedb::Oid &);

  eyedb::Status name(GroupName*);
  GroupName*name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const GroupName*name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid name_oid(eyedb::Status * = 0) const;
  eyedb::Status name_oid(const eyedb::Oid &);

  eyedb::Status length_counts(eyedb::CollArray*);
  eyedb::CollArray*length_counts(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int length_counts_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = length_counts(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollArray*length_counts(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status setin_length_counts_at(int where, SupercontigSet*, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_length_counts_at(int where);
  eyedb::Status setin_length_counts_at(int where, const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_length_counts_at(const eyedb::Oid &);
  const SupercontigSet*length_counts_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const;
  SupercontigSet*length_counts_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0);
  eyedb::Oid length_counts_oidat(unsigned int ind, eyedb::Status *rs = 0) const;

  eyedb::Status ctg_counts(eyedb::CollArray*);
  eyedb::CollArray*ctg_counts(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int ctg_counts_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = ctg_counts(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollArray*ctg_counts(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status setin_ctg_counts_at(int where, SupercontigSet*, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_ctg_counts_at(int where);
  eyedb::Status setin_ctg_counts_at(int where, const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_ctg_counts_at(const eyedb::Oid &);
  const SupercontigSet*ctg_counts_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const;
  SupercontigSet*ctg_counts_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0);
  eyedb::Oid ctg_counts_oidat(unsigned int ind, eyedb::Status *rs = 0) const;

  eyedb::Status cseq_counts(eyedb::CollArray*);
  eyedb::CollArray*cseq_counts(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  unsigned int cseq_counts_cnt(eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const {const eyedb::Collection* _coll = cseq_counts(isnull, rs); return (!!_coll ? _coll->getCount() : 0);}
  const eyedb::CollArray*cseq_counts(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Status setin_cseq_counts_at(int where, SupercontigSet*, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_cseq_counts_at(int where);
  eyedb::Status setin_cseq_counts_at(int where, const eyedb::Oid &, const eyedb::IndexImpl * = 0);
  eyedb::Status unsetin_cseq_counts_at(const eyedb::Oid &);
  const SupercontigSet*cseq_counts_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0) const;
  SupercontigSet*cseq_counts_at(unsigned int ind, eyedb::Bool *isnull = 0, eyedb::Status *rs = 0);
  eyedb::Oid cseq_counts_oidat(unsigned int ind, eyedb::Status *rs = 0) const;
  virtual ~Group() {garbageRealize();}

 protected:
  Group(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Group(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Group(const Group *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Group(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Group(const Group *, eyedb::Bool = eyedb::False);
  Group(const eyedb::Class *, eyedb::Data);
};

struct StageType:Root
{
	static char const*_classname(){return"StageType";}
	static StageType*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asStageType();return 0;}

 public:
  StageType(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  StageType(const StageType& x);

  virtual eyedb::Object *_clone() const {return new StageType(*this);};

  StageType& operator=(const StageType& x);

  virtual StageType *asStageType() {return this;}
  virtual const StageType *asStageType() const {return this;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status comment(const std::string &);
  eyedb::Status comment(unsigned int a0, char );
  std::string comment(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char comment(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~StageType() {garbageRealize();}

 protected:
  StageType(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  StageType(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  StageType(const StageType *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  StageType(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  StageType(const StageType *, eyedb::Bool = eyedb::False);
  StageType(const eyedb::Class *, eyedb::Data);
};

struct Stage:Root
{
	static char const*_classname(){return"Stage";}
	static Stage*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asStage();return 0;}

 public:
  Stage(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Stage(const Stage& x);

  virtual eyedb::Object *_clone() const {return new Stage(*this);};

  Stage& operator=(const Stage& x);

  virtual Stage *asStage() {return this;}
  virtual const Stage *asStage() const {return this;}

  eyedb::Status id(eyedblib::int32 );
  eyedblib::int32 id(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status groups(unsigned int a0, Group*);
  eyedb::Status groups_cnt(unsigned int a0);
  Group*groups(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Group*groups(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  unsigned int groups_cnt(eyedb::Status * = 0) const;

  eyedb::Status stage_type(StageType*);
  StageType*stage_type(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const StageType*stage_type(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid stage_type_oid(eyedb::Status * = 0) const;
  eyedb::Status stage_type_oid(const eyedb::Oid &);
  virtual ~Stage() {garbageRealize();}

 protected:
  Stage(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Stage(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Stage(const Stage *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Stage(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Stage(const Stage *, eyedb::Bool = eyedb::False);
  Stage(const eyedb::Class *, eyedb::Data);
};

struct Algorithm:Root
{
	static char const*_classname(){return"Algorithm";}
	static Algorithm*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asAlgorithm();return 0;}

 public:
  Algorithm(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Algorithm(const Algorithm& x);

  virtual eyedb::Object *_clone() const {return new Algorithm(*this);};

  Algorithm& operator=(const Algorithm& x);

  virtual Algorithm *asAlgorithm() {return this;}
  virtual const Algorithm *asAlgorithm() const {return this;}

  eyedb::Status name(const std::string &);
  eyedb::Status name(unsigned int a0, char );
  std::string name(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char name(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status comment(const std::string &);
  eyedb::Status comment(unsigned int a0, char );
  std::string comment(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  char comment(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Algorithm() {garbageRealize();}

 protected:
  Algorithm(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Algorithm(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Algorithm(const Algorithm *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Algorithm(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Algorithm(const Algorithm *, eyedb::Bool = eyedb::False);
  Algorithm(const eyedb::Class *, eyedb::Data);
};

struct MatchSide:Root
{
	static char const*_classname(){return"MatchSide";}
	static MatchSide*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asMatchSide();return 0;}

 public:
  MatchSide(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  MatchSide(const MatchSide& x);

  virtual eyedb::Object *_clone() const {return new MatchSide(*this);};

  MatchSide& operator=(const MatchSide& x);

  virtual MatchSide *asMatchSide() {return this;}
  virtual const MatchSide *asMatchSide() const {return this;}

  eyedb::Status sequence(ContinuousSequence*);
  ContinuousSequence*sequence(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const ContinuousSequence*sequence(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid sequence_oid(eyedb::Status * = 0) const;
  eyedb::Status sequence_oid(const eyedb::Oid &);

  eyedb::Status start(eyedblib::int32 );
  eyedblib::int32 start(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;

  eyedb::Status stop(eyedblib::int32 );
  eyedblib::int32 stop(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~MatchSide() {garbageRealize();}

 protected:
  MatchSide(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  MatchSide(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  MatchSide(const MatchSide *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  MatchSide(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  MatchSide(const MatchSide *, eyedb::Bool = eyedb::False);
  MatchSide(const eyedb::Class *, eyedb::Data);
};

struct Match:Root
{
	static char const*_classname(){return"Match";}
	static Match*_convert(eyedb::Object*o){if(!o)return 0;if(Root*x=mekanoDatabase::asRoot(o))return x->asMatch();return 0;}

 public:
  Match(eyedb::Database * = 0, const eyedb::Dataspace * = 0);
  Match(const Match& x);

  virtual eyedb::Object *_clone() const {return new Match(*this);};

  Match& operator=(const Match& x);

  virtual Match *asMatch() {return this;}
  virtual const Match *asMatch() const {return this;}

  eyedb::Status algorithm(Algorithm*);
  Algorithm*algorithm(eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const Algorithm*algorithm(eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;
  eyedb::Oid algorithm_oid(eyedb::Status * = 0) const;
  eyedb::Status algorithm_oid(const eyedb::Oid &);

  eyedb::Status sides(unsigned int a0, MatchSide*);
  MatchSide*sides(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) ;
  const MatchSide*sides(unsigned int a0, eyedb::Bool *isnull = 0, eyedb::Status * = 0) const;

  eyedb::Status id_ratio(double );
  double id_ratio(eyedb::Bool *isnull = 0, eyedb::Status * = 0)  const;
  virtual ~Match() {garbageRealize();}

 protected:
  Match(eyedb::Database *_db, const eyedb::Dataspace *_dataspace, int) : Root(_db, _dataspace, 1) {}
  Match(const eyedb::Struct *x, eyedb::Bool share, int) : Root(x, share, 1) {}
  Match(const Match *x, eyedb::Bool share, int) : Root(x, share, 1) {}

 private:
  void initialize(eyedb::Database *_db);

 public: /* restricted */
  Match(const eyedb::Struct *, eyedb::Bool = eyedb::False);
  Match(const Match *, eyedb::Bool = eyedb::False);
  Match(const eyedb::Class *, eyedb::Data);
};


inline Root *Root_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Root *)0;
  return x->asRoot();
}

inline const Root *Root_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Root *)0;
  return x->asRoot();
}

inline Bank *Bank_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Bank *)0;
  return x->asBank();
}

inline const Bank *Bank_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Bank *)0;
  return x->asBank();
}

inline Clone *Clone_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Clone *)0;
  return x->asClone();
}

inline const Clone *Clone_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Clone *)0;
  return x->asClone();
}

inline Read *Read_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Read *)0;
  return x->asRead();
}

inline const Read *Read_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Read *)0;
  return x->asRead();
}

inline Sequence *Sequence_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Sequence *)0;
  return x->asSequence();
}

inline const Sequence *Sequence_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Sequence *)0;
  return x->asSequence();
}

inline ReadPosition *ReadPosition_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (ReadPosition *)0;
  return x->asReadPosition();
}

inline const ReadPosition *ReadPosition_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const ReadPosition *)0;
  return x->asReadPosition();
}

inline ContinuousSequence *ContinuousSequence_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (ContinuousSequence *)0;
  return x->asContinuousSequence();
}

inline const ContinuousSequence *ContinuousSequence_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const ContinuousSequence *)0;
  return x->asContinuousSequence();
}

inline Contig *Contig_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Contig *)0;
  return x->asContig();
}

inline const Contig *Contig_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Contig *)0;
  return x->asContig();
}

inline Cut *Cut_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Cut *)0;
  return x->asCut();
}

inline const Cut *Cut_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Cut *)0;
  return x->asCut();
}

inline Metacontig *Metacontig_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Metacontig *)0;
  return x->asMetacontig();
}

inline const Metacontig *Metacontig_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Metacontig *)0;
  return x->asMetacontig();
}

inline Region *Region_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Region *)0;
  return x->asRegion();
}

inline const Region *Region_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Region *)0;
  return x->asRegion();
}

inline LinkCount *LinkCount_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (LinkCount *)0;
  return x->asLinkCount();
}

inline const LinkCount *LinkCount_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const LinkCount *)0;
  return x->asLinkCount();
}

inline LinkCounts *LinkCounts_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (LinkCounts *)0;
  return x->asLinkCounts();
}

inline const LinkCounts *LinkCounts_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const LinkCounts *)0;
  return x->asLinkCounts();
}

inline Supercontig *Supercontig_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Supercontig *)0;
  return x->asSupercontig();
}

inline const Supercontig *Supercontig_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Supercontig *)0;
  return x->asSupercontig();
}

inline SupercontigPair *SupercontigPair_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (SupercontigPair *)0;
  return x->asSupercontigPair();
}

inline const SupercontigPair *SupercontigPair_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const SupercontigPair *)0;
  return x->asSupercontigPair();
}

inline Calculated *Calculated_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Calculated *)0;
  return x->asCalculated();
}

inline const Calculated *Calculated_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Calculated *)0;
  return x->asCalculated();
}

inline Parameters *Parameters_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Parameters *)0;
  return x->asParameters();
}

inline const Parameters *Parameters_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Parameters *)0;
  return x->asParameters();
}

inline GroupName *GroupName_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (GroupName *)0;
  return x->asGroupName();
}

inline const GroupName *GroupName_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const GroupName *)0;
  return x->asGroupName();
}

inline SupercontigSet *SupercontigSet_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (SupercontigSet *)0;
  return x->asSupercontigSet();
}

inline const SupercontigSet *SupercontigSet_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const SupercontigSet *)0;
  return x->asSupercontigSet();
}

inline Group *Group_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Group *)0;
  return x->asGroup();
}

inline const Group *Group_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Group *)0;
  return x->asGroup();
}

inline StageType *StageType_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (StageType *)0;
  return x->asStageType();
}

inline const StageType *StageType_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const StageType *)0;
  return x->asStageType();
}

inline Stage *Stage_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Stage *)0;
  return x->asStage();
}

inline const Stage *Stage_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Stage *)0;
  return x->asStage();
}

inline Algorithm *Algorithm_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Algorithm *)0;
  return x->asAlgorithm();
}

inline const Algorithm *Algorithm_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Algorithm *)0;
  return x->asAlgorithm();
}

inline MatchSide *MatchSide_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (MatchSide *)0;
  return x->asMatchSide();
}

inline const MatchSide *MatchSide_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const MatchSide *)0;
  return x->asMatchSide();
}

inline Match *Match_c(eyedb::Object *o)
{
  Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (Match *)0;
  return x->asMatch();
}

inline const Match *Match_c(const eyedb::Object *o)
{
  const Root *x = mekanoDatabase::asRoot(o);
  if (!x) return (const Match *)0;
  return x->asMatch();
}

extern eyedb::Object *mekanoMakeObject(eyedb::Object *, eyedb::Bool=eyedb::True);
extern eyedb::Bool mekano_set_oid_check(eyedb::Bool);
extern eyedb::Bool mekano_get_oid_check();


}

#endif
