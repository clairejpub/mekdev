
/*
 * EyeDB Version 2.7.13 Copyright (c) 1995-2006 SYSRA
 *
 * File 'mekano.cc'
 *
 * Package Name 'mekano'
 *
 * Generated by eyedbodl at Mon Apr 28 17:01:31 2008
 *
 * ---------------------------------------------------
 * -------------- DO NOT EDIT THIS CODE --------------
 * ---------------------------------------------------
 *
 */

#include <eyedb/eyedb.h>

#include <eyedb/internals/ObjectPeer.h>
#include <eyedb/internals/ClassPeer.h>
#include <eyedb/internals/kern_const.h>

#include "mekano.h"

#define min(x,y)((x)<(y)?(x):(y))

namespace mekano {

static eyedb::Bool dynget_error_policy = eyedb::False;
static eyedb::Bool dynset_error_policy = eyedb::True;
static eyedb::Oid nulloid;
static unsigned char nulldata[1];
static eyedb::Bool oid_check = eyedb::True;
static int class_ind;
static eyedb::Database::consapp_t *constructors_x = new eyedb::Database::consapp_t[135];
static eyedb::Object *(*constructors[135])(const eyedb::Object *, eyedb::Bool);
static eyedb::GenHashTable *hash;
#define make_object mekanoMakeObject
extern void mekanoInit(void);
extern void mekanoRelease(void);
extern eyedb::Status mekanoSchemaUpdate(eyedb::Database *);
extern eyedb::Status mekanoSchemaUpdate(eyedb::Schema *);

static eyedb::Class *index_Class = new eyedb::Class("index");

void mekano::init()
{
  mekanoInit();
}

void mekano::release()
{
  mekanoRelease();
}

eyedb::Status mekano::updateSchema(eyedb::Database *db)
{
  return mekanoSchemaUpdate(db);
}

eyedb::Status mekano::updateSchema(eyedb::Schema *m)
{
  return mekanoSchemaUpdate(m);
}

static eyedb::StructClass *Root_Class;
static eyedb::StructClass *Bank_Class;
static eyedb::StructClass *Clone_Class;
static eyedb::StructClass *Read_Class;
static eyedb::StructClass *Sequence_Class;
static eyedb::StructClass *ReadPosition_Class;
static eyedb::StructClass *ContinuousSequence_Class;
static eyedb::StructClass *Contig_Class;
static eyedb::StructClass *Cut_Class;
static eyedb::StructClass *Metacontig_Class;
static eyedb::StructClass *Region_Class;
static eyedb::StructClass *LinkCount_Class;
static eyedb::StructClass *LinkCounts_Class;
static eyedb::StructClass *Supercontig_Class;
static eyedb::StructClass *SupercontigPair_Class;
static eyedb::StructClass *Calculated_Class;
static eyedb::StructClass *Parameters_Class;
static eyedb::StructClass *GroupName_Class;
static eyedb::StructClass *SupercontigSet_Class;
static eyedb::StructClass *Group_Class;
static eyedb::StructClass *StageType_Class;
static eyedb::StructClass *Stage_Class;
static eyedb::StructClass *Algorithm_Class;
static eyedb::StructClass *MatchSide_Class;
static eyedb::StructClass *Match_Class;
static eyedb::CollBagClass *bag_class_SupercontigPair_Class;
static eyedb::CollArrayClass *array_class_bag_class_SupercontigPair_ref_Class;
static eyedb::CollSetClass *set_class_Supercontig_ref_Class;
static eyedb::CollArrayClass *array_class_SupercontigSet_ref_Class;

static const eyedb::Attribute **Root_agritems;
static eyedb::Size Root_idr_objsz, Root_idr_psize;

static eyedb::StructClass *Root_make(eyedb::StructClass *Root_class = 0, eyedb::Schema *m = 0)
{
  if (!Root_class)
    return new eyedb::StructClass("Root", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[2];

  Root_class->setAttributes(&attr[2], 0);



  return Root_class;
}

eyedb::Object *Root_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Root(cls, idr);
}

eyedb::Object *Root_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Root((const eyedb::Struct *)o, share);
}

static void Root_init_p()
{
  Root_Class = Root_make();
  constructors_x[class_ind] = Root_construct_x;
  constructors[class_ind] = Root_construct;
  hash->insert("Root", class_ind++);
}

static void Root_init()
{
  Root_make(Root_Class);

  Root_agritems = Root_Class->getAttributes();
  Root_idr_objsz = Root_Class->getIDRObjectSize(&Root_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Root_Class, eyedb::True);
}

static eyedb::Status Root_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Root::Root(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : eyedb::Struct(_db, _dataspace)
{
  initialize(_db);
}

Root::Root(const eyedb::Class *_cls, eyedb::Data _idr)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Root::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Root") : Root_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Root::Root(const Root& x) : eyedb::Struct(x)
{
  userCopy(x);
}

Root& Root::operator=(const Root& x)
{
  *(eyedb::Struct *)this = eyedb::Struct::operator=((const eyedb::Struct &)x);
  userCopy(x);
  return *this;
}

Root::Root(const eyedb::Struct *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("Root") : Root_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Root::Root(const Root *x, eyedb::Bool share) : eyedb::Struct(x, share)
{
  setClass((db ? db->getSchema()->getClass("Root") : Root_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **Bank_agritems;
static eyedb::Size Bank_idr_objsz, Bank_idr_psize;

static eyedb::StructClass *Bank_make(eyedb::StructClass *Bank_class = 0, eyedb::Schema *m = 0)
{
  if (!Bank_class)
    return new eyedb::StructClass("Bank", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "length", eyedb::False, 0, dims);

  Bank_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return Bank_class;
}

eyedb::Object *Bank_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Bank(cls, idr);
}

eyedb::Object *Bank_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Bank((const eyedb::Struct *)o, share);
}

static void Bank_init_p()
{
  Bank_Class = Bank_make();
  constructors_x[class_ind] = Bank_construct_x;
  constructors[class_ind] = Bank_construct;
  hash->insert("Bank", class_ind++);
}

static void Bank_init()
{
  Bank_make(Bank_Class);

  Bank_agritems = Bank_Class->getAttributes();
  Bank_idr_objsz = Bank_Class->getIDRObjectSize(&Bank_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Bank_Class, eyedb::True);
}

static eyedb::Status Bank_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "Bank.name", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "Bank.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  comp = new eyedb::NotNullConstraint(db, cls, "Bank.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Bank::Bank(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Bank::Bank(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Bank::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Bank") : Bank_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Bank::Bank(const Bank& x) : Root(x)
{
  userCopy(x);
}

Bank& Bank::operator=(const Bank& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Bank::Bank(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Bank") : Bank_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Bank::Bank(const Bank *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Bank") : Bank_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Bank::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status Bank::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string Bank::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Bank::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Bank::length(eyedblib::int32 _length)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_length, 1, 0);
  return status;
}

eyedblib::int32 Bank::length(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **Clone_agritems;
static eyedb::Size Clone_idr_objsz, Clone_idr_psize;

static eyedb::StructClass *Clone_make(eyedb::StructClass *Clone_class = 0, eyedb::Schema *m = 0)
{
  if (!Clone_class)
    return new eyedb::StructClass("Clone", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = 23;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("Bank") : Bank_Class), "bank", eyedb::True, 0, dims);

  Clone_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return Clone_class;
}

eyedb::Object *Clone_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Clone(cls, idr);
}

eyedb::Object *Clone_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Clone((const eyedb::Struct *)o, share);
}

static void Clone_init_p()
{
  Clone_Class = Clone_make();
  constructors_x[class_ind] = Clone_construct_x;
  constructors[class_ind] = Clone_construct;
  hash->insert("Clone", class_ind++);
}

static void Clone_init()
{
  Clone_make(Clone_Class);

  Clone_agritems = Clone_Class->getAttributes();
  Clone_idr_objsz = Clone_Class->getIDRObjectSize(&Clone_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Clone_Class, eyedb::True);
}

static eyedb::Status Clone_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "Clone.name", eyedb::True, eyedb::True, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "Clone.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  comp = new eyedb::NotNullConstraint(db, cls, "Clone.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Clone::Clone(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Clone::Clone(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Clone::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Clone") : Clone_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Clone::Clone(const Clone& x) : Root(x)
{
  userCopy(x);
}

Clone& Clone::operator=(const Clone& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Clone::Clone(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Clone") : Clone_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Clone::Clone(const Clone *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Clone") : Clone_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Clone::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  unsigned char data[23];
  eyedb::Size len = _name.size();
  if (len >= 23)
    return eyedb::Exception::make(eyedb::IDB_ERROR, "string `%s' [%d] too long for attribute Clone::name, maximum is 23\n", _name.c_str(), len);
  memset(data, 0, 23);
  strncpy((char *)data, _name.c_str(), min(22, len));
  status = getClass()->getAttributes()[2]->setValue(this, data, 23, 0);
  return status;

}

eyedb::Status Clone::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string Clone::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (const char *)data;
}

char Clone::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Clone::bank(Bank*_bank)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_obank = _bank;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_obank, 1, 0);
  return status;
}

const Bank*Clone::bank(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Bank *)__o;
     }
     __go = (Bank *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Bank*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Bank *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Bank*)__o;
}

Bank*Clone::bank(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Bank *)__o;
     }
     __go = (Bank *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Bank*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Bank *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Bank*)__o;
}

eyedb::Status Clone::bank_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Clone::bank_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **Read_agritems;
static eyedb::Size Read_idr_objsz, Read_idr_psize;

static eyedb::StructClass *Read_make(eyedb::StructClass *Read_class = 0, eyedb::Schema *m = 0)
{
  if (!Read_class)
    return new eyedb::StructClass("Read", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = new int[1];
  dims[0] = 23;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("Clone") : Clone_Class), "clone", eyedb::True, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "length", eyedb::False, 0, dims);

  Read_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return Read_class;
}

eyedb::Object *Read_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Read(cls, idr);
}

eyedb::Object *Read_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Read((const eyedb::Struct *)o, share);
}

static void Read_init_p()
{
  Read_Class = Read_make();
  constructors_x[class_ind] = Read_construct_x;
  constructors[class_ind] = Read_construct;
  hash->insert("Read", class_ind++);
}

static void Read_init()
{
  Read_make(Read_Class);

  Read_agritems = Read_Class->getAttributes();
  Read_idr_objsz = Read_Class->getIDRObjectSize(&Read_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Read_Class, eyedb::True);
}

static eyedb::Status Read_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "Read.name", eyedb::True, eyedb::True, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "Read.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  comp = new eyedb::NotNullConstraint(db, cls, "Read.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Read::Read(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Read::Read(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Read::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Read") : Read_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Read::Read(const Read& x) : Root(x)
{
  userCopy(x);
}

Read& Read::operator=(const Read& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Read::Read(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Read") : Read_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Read::Read(const Read *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Read") : Read_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Read::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  unsigned char data[23];
  eyedb::Size len = _name.size();
  if (len >= 23)
    return eyedb::Exception::make(eyedb::IDB_ERROR, "string `%s' [%d] too long for attribute Read::name, maximum is 23\n", _name.c_str(), len);
  memset(data, 0, 23);
  strncpy((char *)data, _name.c_str(), min(22, len));
  status = getClass()->getAttributes()[2]->setValue(this, data, 23, 0);
  return status;

}

eyedb::Status Read::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string Read::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (const char *)data;
}

char Read::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Read::clone(Clone*_clone)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oclone = _clone;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_oclone, 1, 0);
  return status;
}

const Clone*Read::clone(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Clone *)__o;
     }
     __go = (Clone *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Clone*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Clone *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Clone*)__o;
}

Clone*Read::clone(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Clone *)__o;
     }
     __go = (Clone *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Clone*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Clone *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Clone*)__o;
}

eyedb::Status Read::clone_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Read::clone_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Read::length(eyedblib::int32 _length)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_length, 1, 0);
  return status;
}

eyedblib::int32 Read::length(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **Sequence_agritems;
static eyedb::Size Sequence_idr_objsz, Sequence_idr_psize;

static eyedb::StructClass *Sequence_make(eyedb::StructClass *Sequence_class = 0, eyedb::Schema *m = 0)
{
  if (!Sequence_class)
    return new eyedb::StructClass("Sequence", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = new int[1];
  dims[0] = 23;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "length", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("Stage") : Stage_Class), "created_in", eyedb::True, 0, dims);

  Sequence_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return Sequence_class;
}

eyedb::Object *Sequence_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Sequence(cls, idr);
}

eyedb::Object *Sequence_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Sequence((const eyedb::Struct *)o, share);
}

static void Sequence_init_p()
{
  Sequence_Class = Sequence_make();
  constructors_x[class_ind] = Sequence_construct_x;
  constructors[class_ind] = Sequence_construct;
  hash->insert("Sequence", class_ind++);
}

static void Sequence_init()
{
  Sequence_make(Sequence_Class);

  Sequence_agritems = Sequence_Class->getAttributes();
  Sequence_idr_objsz = Sequence_Class->getIDRObjectSize(&Sequence_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Sequence_Class, eyedb::True);
}

static eyedb::Status Sequence_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "Sequence.name", eyedb::True, eyedb::True, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "Sequence.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Sequence::Sequence(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Sequence::Sequence(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Sequence::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Sequence") : Sequence_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Sequence::Sequence(const Sequence& x) : Root(x)
{
  userCopy(x);
}

Sequence& Sequence::operator=(const Sequence& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Sequence::Sequence(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Sequence") : Sequence_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Sequence::Sequence(const Sequence *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Sequence") : Sequence_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Sequence::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  unsigned char data[23];
  eyedb::Size len = _name.size();
  if (len >= 23)
    return eyedb::Exception::make(eyedb::IDB_ERROR, "string `%s' [%d] too long for attribute Sequence::name, maximum is 23\n", _name.c_str(), len);
  memset(data, 0, 23);
  strncpy((char *)data, _name.c_str(), min(22, len));
  status = getClass()->getAttributes()[2]->setValue(this, data, 23, 0);
  return status;

}

eyedb::Status Sequence::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string Sequence::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (const char *)data;
}

char Sequence::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Sequence::length(eyedblib::int32 _length)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_length, 1, 0);
  return status;
}

eyedblib::int32 Sequence::length(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Sequence::created_in(Stage*_created_in)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocreated_in = _created_in;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_ocreated_in, 1, 0);
  return status;
}

const Stage*Sequence::created_in(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Stage *)__o;
     }
     __go = (Stage *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Stage*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Stage *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Stage*)__o;
}

Stage*Sequence::created_in(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Stage *)__o;
     }
     __go = (Stage *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Stage*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Stage *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Stage*)__o;
}

eyedb::Status Sequence::created_in_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Sequence::created_in_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **ReadPosition_agritems;
static eyedb::Size ReadPosition_idr_objsz, ReadPosition_idr_psize;

static eyedb::StructClass *ReadPosition_make(eyedb::StructClass *ReadPosition_class = 0, eyedb::Schema *m = 0)
{
  if (!ReadPosition_class)
    return new eyedb::StructClass("ReadPosition", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[7];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("Read") : Read_Class), "read", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "start_on_read", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "start_on_contig", eyedb::False, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "length", eyedb::False, 0, dims);

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("bool") : eyedb::Bool_Class), "forward", eyedb::False, 0, dims);

  ReadPosition_class->setAttributes(&attr[2], 5);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];


  return ReadPosition_class;
}

eyedb::Object *ReadPosition_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ReadPosition(cls, idr);
}

eyedb::Object *ReadPosition_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ReadPosition((const eyedb::Struct *)o, share);
}

static void ReadPosition_init_p()
{
  ReadPosition_Class = ReadPosition_make();
  constructors_x[class_ind] = ReadPosition_construct_x;
  constructors[class_ind] = ReadPosition_construct;
  hash->insert("ReadPosition", class_ind++);
}

static void ReadPosition_init()
{
  ReadPosition_make(ReadPosition_Class);

  ReadPosition_agritems = ReadPosition_Class->getAttributes();
  ReadPosition_idr_objsz = ReadPosition_Class->getIDRObjectSize(&ReadPosition_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ReadPosition_Class, eyedb::True);
}

static eyedb::Status ReadPosition_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

ReadPosition::ReadPosition(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

ReadPosition::ReadPosition(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ReadPosition::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("ReadPosition") : ReadPosition_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ReadPosition::ReadPosition(const ReadPosition& x) : Root(x)
{
  userCopy(x);
}

ReadPosition& ReadPosition::operator=(const ReadPosition& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

ReadPosition::ReadPosition(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("ReadPosition") : ReadPosition_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ReadPosition::ReadPosition(const ReadPosition *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("ReadPosition") : ReadPosition_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status ReadPosition::read(Read*_read)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oread = _read;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_oread, 1, 0);
  return status;
}

const Read*ReadPosition::read(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Read *)__o;
     }
     __go = (Read *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Read*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Read *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Read*)__o;
}

Read*ReadPosition::read(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Read *)__o;
     }
     __go = (Read *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Read*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Read *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Read*)__o;
}

eyedb::Status ReadPosition::read_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid ReadPosition::read_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status ReadPosition::start_on_read(eyedblib::int32 _start_on_read)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_start_on_read, 1, 0);
  return status;
}

eyedblib::int32 ReadPosition::start_on_read(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ReadPosition::start_on_contig(eyedblib::int32 _start_on_contig)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_start_on_contig, 1, 0);
  return status;
}

eyedblib::int32 ReadPosition::start_on_contig(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ReadPosition::length(eyedblib::int32 _length)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_length, 1, 0);
  return status;
}

eyedblib::int32 ReadPosition::length(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status ReadPosition::forward(eyedb::Bool _forward, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _forward;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

eyedb::Bool ReadPosition::forward(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (eyedb::Bool)0;}
  return (eyedb::Bool)__tmp;
}

static const eyedb::Attribute **ContinuousSequence_agritems;
static eyedb::Size ContinuousSequence_idr_objsz, ContinuousSequence_idr_psize;

static eyedb::StructClass *ContinuousSequence_make(eyedb::StructClass *ContinuousSequence_class = 0, eyedb::Schema *m = 0)
{
  if (!ContinuousSequence_class)
    return new eyedb::StructClass("ContinuousSequence", (m ? m->getClass("Sequence") : Sequence_Class));
  eyedb::Attribute *attr[5];

  ContinuousSequence_class->setAttributes(&attr[5], 0);



  return ContinuousSequence_class;
}

eyedb::Object *ContinuousSequence_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new ContinuousSequence(cls, idr);
}

eyedb::Object *ContinuousSequence_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new ContinuousSequence((const eyedb::Struct *)o, share);
}

static void ContinuousSequence_init_p()
{
  ContinuousSequence_Class = ContinuousSequence_make();
  constructors_x[class_ind] = ContinuousSequence_construct_x;
  constructors[class_ind] = ContinuousSequence_construct;
  hash->insert("ContinuousSequence", class_ind++);
}

static void ContinuousSequence_init()
{
  ContinuousSequence_make(ContinuousSequence_Class);

  ContinuousSequence_agritems = ContinuousSequence_Class->getAttributes();
  ContinuousSequence_idr_objsz = ContinuousSequence_Class->getIDRObjectSize(&ContinuousSequence_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(ContinuousSequence_Class, eyedb::True);
}

static eyedb::Status ContinuousSequence_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

ContinuousSequence::ContinuousSequence(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Sequence(_db, _dataspace, 1)
{
  initialize(_db);
}

ContinuousSequence::ContinuousSequence(const eyedb::Class *_cls, eyedb::Data _idr): Sequence((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void ContinuousSequence::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("ContinuousSequence") : ContinuousSequence_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

ContinuousSequence::ContinuousSequence(const ContinuousSequence& x) : Sequence(x)
{
  userCopy(x);
}

ContinuousSequence& ContinuousSequence::operator=(const ContinuousSequence& x)
{
  *(Sequence *)this = Sequence::operator=((const Sequence &)x);
  userCopy(x);
  return *this;
}

ContinuousSequence::ContinuousSequence(const eyedb::Struct *x, eyedb::Bool share) : Sequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("ContinuousSequence") : ContinuousSequence_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

ContinuousSequence::ContinuousSequence(const ContinuousSequence *x, eyedb::Bool share) : Sequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("ContinuousSequence") : ContinuousSequence_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

static const eyedb::Attribute **Contig_agritems;
static eyedb::Size Contig_idr_objsz, Contig_idr_psize;

static eyedb::StructClass *Contig_make(eyedb::StructClass *Contig_class = 0, eyedb::Schema *m = 0)
{
  if (!Contig_class)
    return new eyedb::StructClass("Contig", (m ? m->getClass("ContinuousSequence") : ContinuousSequence_Class));
  eyedb::Attribute *attr[7];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[5] = new eyedb::Attribute((m ? m->getClass("ReadPosition") : ReadPosition_Class), "reads", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[6] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "consensus", eyedb::False, 1, dims);
  delete[] dims;

  Contig_class->setAttributes(&attr[5], 2);

  delete attr[5];
  delete attr[6];


  return Contig_class;
}

eyedb::Object *Contig_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Contig(cls, idr);
}

eyedb::Object *Contig_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Contig((const eyedb::Struct *)o, share);
}

static void Contig_init_p()
{
  Contig_Class = Contig_make();
  constructors_x[class_ind] = Contig_construct_x;
  constructors[class_ind] = Contig_construct;
  hash->insert("Contig", class_ind++);
}

static void Contig_init()
{
  Contig_make(Contig_Class);

  Contig_agritems = Contig_Class->getAttributes();
  Contig_idr_objsz = Contig_Class->getIDRObjectSize(&Contig_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Contig_Class, eyedb::True);
}

static eyedb::Status Contig_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Contig::Contig(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : ContinuousSequence(_db, _dataspace, 1)
{
  initialize(_db);
}

Contig::Contig(const eyedb::Class *_cls, eyedb::Data _idr): ContinuousSequence((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Contig::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Contig") : Contig_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Contig::Contig(const Contig& x) : ContinuousSequence(x)
{
  userCopy(x);
}

Contig& Contig::operator=(const Contig& x)
{
  *(ContinuousSequence *)this = ContinuousSequence::operator=((const ContinuousSequence &)x);
  userCopy(x);
  return *this;
}

Contig::Contig(const eyedb::Struct *x, eyedb::Bool share) : ContinuousSequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Contig") : Contig_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Contig::Contig(const Contig *x, eyedb::Bool share) : ContinuousSequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Contig") : Contig_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Contig::reads(unsigned int a0, ReadPosition*_reads)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[5]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_oreads = _reads;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_oreads, 1, from);
  return status;
}

eyedb::Status Contig::reads_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[5]->setSize(this, from);
  return status;
}

const ReadPosition*Contig::reads(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ReadPosition *)__o;
     }
     __go = (ReadPosition *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ReadPosition*)__o;
}

ReadPosition*Contig::reads(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ReadPosition *)__o;
     }
     __go = (ReadPosition *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (ReadPosition*)__o;
}

unsigned int Contig::reads_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[5]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

eyedb::Status Contig::consensus(const std::string &_consensus)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _consensus.size() + 1;

  status = getClass()->getAttributes()[6]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[6]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)_consensus.c_str(), len, 0);
  return status;

}

eyedb::Status Contig::consensus(unsigned int a0, char _consensus)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[6]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[6]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_consensus, 1, from);
  return status;
}

std::string Contig::consensus(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Contig::consensus(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **Cut_agritems;
static eyedb::Size Cut_idr_objsz, Cut_idr_psize;

static eyedb::StructClass *Cut_make(eyedb::StructClass *Cut_class = 0, eyedb::Schema *m = 0)
{
  if (!Cut_class)
    return new eyedb::StructClass("Cut", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[7];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("ContinuousSequence") : ContinuousSequence_Class), "cseq", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "start", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "stop", eyedb::False, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("Supercontig") : Supercontig_Class), "source", eyedb::True, 0, dims);

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("bool") : eyedb::Bool_Class), "source_forward", eyedb::False, 0, dims);

  Cut_class->setAttributes(&attr[2], 5);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];


  return Cut_class;
}

eyedb::Object *Cut_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Cut(cls, idr);
}

eyedb::Object *Cut_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Cut((const eyedb::Struct *)o, share);
}

static void Cut_init_p()
{
  Cut_Class = Cut_make();
  constructors_x[class_ind] = Cut_construct_x;
  constructors[class_ind] = Cut_construct;
  hash->insert("Cut", class_ind++);
}

static void Cut_init()
{
  Cut_make(Cut_Class);

  Cut_agritems = Cut_Class->getAttributes();
  Cut_idr_objsz = Cut_Class->getIDRObjectSize(&Cut_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Cut_Class, eyedb::True);
}

static eyedb::Status Cut_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Cut::Cut(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Cut::Cut(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Cut::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Cut") : Cut_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Cut::Cut(const Cut& x) : Root(x)
{
  userCopy(x);
}

Cut& Cut::operator=(const Cut& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Cut::Cut(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Cut") : Cut_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Cut::Cut(const Cut *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Cut") : Cut_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Cut::cseq(ContinuousSequence*_cseq)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocseq = _cseq;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_ocseq, 1, 0);
  return status;
}

const ContinuousSequence*Cut::cseq(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

ContinuousSequence*Cut::cseq(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

eyedb::Status Cut::cseq_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Cut::cseq_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Cut::start(eyedblib::int32 _start)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_start, 1, 0);
  return status;
}

eyedblib::int32 Cut::start(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Cut::stop(eyedblib::int32 _stop)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_stop, 1, 0);
  return status;
}

eyedblib::int32 Cut::stop(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Cut::source(Supercontig*_source)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osource = _source;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_osource, 1, 0);
  return status;
}

const Supercontig*Cut::source(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

Supercontig*Cut::source(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[5]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[5]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

eyedb::Status Cut::source_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[5]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Cut::source_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Cut::source_forward(eyedb::Bool _source_forward, eyedb::Bool _check_value)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedblib::int32 __tmp = _source_forward;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&__tmp, 1, 0, _check_value);
  return status;
}

eyedb::Bool Cut::source_forward(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32  __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return (eyedb::Bool)0;}
  return (eyedb::Bool)__tmp;
}

static const eyedb::Attribute **Metacontig_agritems;
static eyedb::Size Metacontig_idr_objsz, Metacontig_idr_psize;

static eyedb::StructClass *Metacontig_make(eyedb::StructClass *Metacontig_class = 0, eyedb::Schema *m = 0)
{
  if (!Metacontig_class)
    return new eyedb::StructClass("Metacontig", (m ? m->getClass("ContinuousSequence") : ContinuousSequence_Class));
  eyedb::Attribute *attr[6];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[5] = new eyedb::Attribute((m ? m->getClass("Cut") : Cut_Class), "cuts", eyedb::False, 1, dims);
  delete[] dims;

  Metacontig_class->setAttributes(&attr[5], 1);

  delete attr[5];


  return Metacontig_class;
}

eyedb::Object *Metacontig_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Metacontig(cls, idr);
}

eyedb::Object *Metacontig_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Metacontig((const eyedb::Struct *)o, share);
}

static void Metacontig_init_p()
{
  Metacontig_Class = Metacontig_make();
  constructors_x[class_ind] = Metacontig_construct_x;
  constructors[class_ind] = Metacontig_construct;
  hash->insert("Metacontig", class_ind++);
}

static void Metacontig_init()
{
  Metacontig_make(Metacontig_Class);

  Metacontig_agritems = Metacontig_Class->getAttributes();
  Metacontig_idr_objsz = Metacontig_Class->getIDRObjectSize(&Metacontig_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Metacontig_Class, eyedb::True);
}

static eyedb::Status Metacontig_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Metacontig::Metacontig(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : ContinuousSequence(_db, _dataspace, 1)
{
  initialize(_db);
}

Metacontig::Metacontig(const eyedb::Class *_cls, eyedb::Data _idr): ContinuousSequence((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Metacontig::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Metacontig") : Metacontig_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Metacontig::Metacontig(const Metacontig& x) : ContinuousSequence(x)
{
  userCopy(x);
}

Metacontig& Metacontig::operator=(const Metacontig& x)
{
  *(ContinuousSequence *)this = ContinuousSequence::operator=((const ContinuousSequence &)x);
  userCopy(x);
  return *this;
}

Metacontig::Metacontig(const eyedb::Struct *x, eyedb::Bool share) : ContinuousSequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Metacontig") : Metacontig_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Metacontig::Metacontig(const Metacontig *x, eyedb::Bool share) : ContinuousSequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Metacontig") : Metacontig_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Metacontig::cuts(unsigned int a0, Cut*_cuts)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[5]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_ocuts = _cuts;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_ocuts, 1, from);
  return status;
}

eyedb::Status Metacontig::cuts_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[5]->setSize(this, from);
  return status;
}

const Cut*Metacontig::cuts(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Cut *)__o;
     }
     __go = (Cut *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Cut*)__o;
}

Cut*Metacontig::cuts(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Cut *)__o;
     }
     __go = (Cut *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Cut*)__o;
}

unsigned int Metacontig::cuts_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[5]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const eyedb::Attribute **Region_agritems;
static eyedb::Size Region_idr_objsz, Region_idr_psize;

static eyedb::StructClass *Region_make(eyedb::StructClass *Region_class = 0, eyedb::Schema *m = 0)
{
  if (!Region_class)
    return new eyedb::StructClass("Region", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[8];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("Sequence") : Sequence_Class), "sequence", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "gap_after", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("ContinuousSequence") : ContinuousSequence_Class), "first", eyedb::True, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "start_on_first", eyedb::False, 0, dims);

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("ContinuousSequence") : ContinuousSequence_Class), "last", eyedb::True, 0, dims);

  dims = 0;
  attr[7] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "stop_on_last", eyedb::False, 0, dims);

  Region_class->setAttributes(&attr[2], 6);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];
  delete attr[7];


  return Region_class;
}

eyedb::Object *Region_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Region(cls, idr);
}

eyedb::Object *Region_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Region((const eyedb::Struct *)o, share);
}

static void Region_init_p()
{
  Region_Class = Region_make();
  constructors_x[class_ind] = Region_construct_x;
  constructors[class_ind] = Region_construct;
  hash->insert("Region", class_ind++);
}

static void Region_init()
{
  Region_make(Region_Class);

  Region_agritems = Region_Class->getAttributes();
  Region_idr_objsz = Region_Class->getIDRObjectSize(&Region_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Region_Class, eyedb::True);
}

static eyedb::Status Region_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Region::Region(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Region::Region(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Region::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Region") : Region_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Region::Region(const Region& x) : Root(x)
{
  userCopy(x);
}

Region& Region::operator=(const Region& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Region::Region(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Region") : Region_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Region::Region(const Region *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Region") : Region_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Region::sequence(Sequence*_sequence)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osequence = _sequence;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_osequence, 1, 0);
  return status;
}

const Sequence*Region::sequence(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Sequence *)__o;
     }
     __go = (Sequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Sequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Sequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Sequence*)__o;
}

Sequence*Region::sequence(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Sequence *)__o;
     }
     __go = (Sequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Sequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Sequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Sequence*)__o;
}

eyedb::Status Region::sequence_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Region::sequence_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Region::gap_after(eyedblib::int32 _gap_after)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_gap_after, 1, 0);
  return status;
}

eyedblib::int32 Region::gap_after(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Region::first(ContinuousSequence*_first)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ofirst = _first;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_ofirst, 1, 0);
  return status;
}

const ContinuousSequence*Region::first(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

ContinuousSequence*Region::first(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

eyedb::Status Region::first_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Region::first_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Region::start_on_first(eyedblib::int32 _start_on_first)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_start_on_first, 1, 0);
  return status;
}

eyedblib::int32 Region::start_on_first(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Region::last(ContinuousSequence*_last)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_olast = _last;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_olast, 1, 0);
  return status;
}

const ContinuousSequence*Region::last(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[6]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[6]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

ContinuousSequence*Region::last(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[6]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[6]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[6]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

eyedb::Status Region::last_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Region::last_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Region::stop_on_last(eyedblib::int32 _stop_on_last)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_stop_on_last, 1, 0);
  return status;
}

eyedblib::int32 Region::stop_on_last(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **LinkCount_agritems;
static eyedb::Size LinkCount_idr_objsz, LinkCount_idr_psize;

static eyedb::StructClass *LinkCount_make(eyedb::StructClass *LinkCount_class = 0, eyedb::Schema *m = 0)
{
  if (!LinkCount_class)
    return new eyedb::StructClass("LinkCount", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("Supercontig") : Supercontig_Class), "sctg", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "n", eyedb::False, 0, dims);

  LinkCount_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return LinkCount_class;
}

eyedb::Object *LinkCount_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new LinkCount(cls, idr);
}

eyedb::Object *LinkCount_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new LinkCount((const eyedb::Struct *)o, share);
}

static void LinkCount_init_p()
{
  LinkCount_Class = LinkCount_make();
  constructors_x[class_ind] = LinkCount_construct_x;
  constructors[class_ind] = LinkCount_construct;
  hash->insert("LinkCount", class_ind++);
}

static void LinkCount_init()
{
  LinkCount_make(LinkCount_Class);

  LinkCount_agritems = LinkCount_Class->getAttributes();
  LinkCount_idr_objsz = LinkCount_Class->getIDRObjectSize(&LinkCount_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(LinkCount_Class, eyedb::True);
}

static eyedb::Status LinkCount_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

LinkCount::LinkCount(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

LinkCount::LinkCount(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void LinkCount::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("LinkCount") : LinkCount_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

LinkCount::LinkCount(const LinkCount& x) : Root(x)
{
  userCopy(x);
}

LinkCount& LinkCount::operator=(const LinkCount& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

LinkCount::LinkCount(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("LinkCount") : LinkCount_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

LinkCount::LinkCount(const LinkCount *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("LinkCount") : LinkCount_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status LinkCount::sctg(Supercontig*_sctg)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osctg = _sctg;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_osctg, 1, 0);
  return status;
}

const Supercontig*LinkCount::sctg(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

Supercontig*LinkCount::sctg(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

eyedb::Status LinkCount::sctg_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid LinkCount::sctg_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status LinkCount::n(eyedblib::int32 _n)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_n, 1, 0);
  return status;
}

eyedblib::int32 LinkCount::n(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **LinkCounts_agritems;
static eyedb::Size LinkCounts_idr_objsz, LinkCounts_idr_psize;

static eyedb::StructClass *LinkCounts_make(eyedb::StructClass *LinkCounts_class = 0, eyedb::Schema *m = 0)
{
  if (!LinkCounts_class)
    return new eyedb::StructClass("LinkCounts", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[3];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("LinkCount") : LinkCount_Class), "link_counts", eyedb::False, 1, dims);
  delete[] dims;

  LinkCounts_class->setAttributes(&attr[2], 1);

  delete attr[2];


  return LinkCounts_class;
}

eyedb::Object *LinkCounts_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new LinkCounts(cls, idr);
}

eyedb::Object *LinkCounts_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new LinkCounts((const eyedb::Struct *)o, share);
}

static void LinkCounts_init_p()
{
  LinkCounts_Class = LinkCounts_make();
  constructors_x[class_ind] = LinkCounts_construct_x;
  constructors[class_ind] = LinkCounts_construct;
  hash->insert("LinkCounts", class_ind++);
}

static void LinkCounts_init()
{
  LinkCounts_make(LinkCounts_Class);

  LinkCounts_agritems = LinkCounts_Class->getAttributes();
  LinkCounts_idr_objsz = LinkCounts_Class->getIDRObjectSize(&LinkCounts_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(LinkCounts_Class, eyedb::True);
}

static eyedb::Status LinkCounts_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

LinkCounts::LinkCounts(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

LinkCounts::LinkCounts(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void LinkCounts::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("LinkCounts") : LinkCounts_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

LinkCounts::LinkCounts(const LinkCounts& x) : Root(x)
{
  userCopy(x);
}

LinkCounts& LinkCounts::operator=(const LinkCounts& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

LinkCounts::LinkCounts(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("LinkCounts") : LinkCounts_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

LinkCounts::LinkCounts(const LinkCounts *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("LinkCounts") : LinkCounts_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status LinkCounts::link_counts(unsigned int a0, LinkCount*_link_counts)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_olink_counts = _link_counts;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_olink_counts, 1, from);
  return status;
}

eyedb::Status LinkCounts::link_counts_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[2]->setSize(this, from);
  return status;
}

const LinkCount*LinkCounts::link_counts(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (LinkCount *)__o;
     }
     __go = (LinkCount *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (LinkCount*)__o;
}

LinkCount*LinkCounts::link_counts(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (LinkCount *)__o;
     }
     __go = (LinkCount *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (LinkCount*)__o;
}

unsigned int LinkCounts::link_counts_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[2]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

static const eyedb::Attribute **Supercontig_agritems;
static eyedb::Size Supercontig_idr_objsz, Supercontig_idr_psize;

static eyedb::StructClass *Supercontig_make(eyedb::StructClass *Supercontig_class = 0, eyedb::Schema *m = 0)
{
  if (!Supercontig_class)
    return new eyedb::StructClass("Supercontig", (m ? m->getClass("Sequence") : Sequence_Class));
  eyedb::Attribute *attr[10];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[5] = new eyedb::Attribute((m ? m->getClass("Region") : Region_Class), "regions", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "nb_ctg", eyedb::False, 0, dims);

  dims = 0;
  attr[7] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "nb_cseq", eyedb::False, 0, dims);

  dims = 0;
  attr[8] = new eyedb::Attribute((m ? m->getClass("LinkCounts") : LinkCounts_Class), "clone_links", eyedb::False, 0, dims);

  dims = 0;
  attr[9] = new eyedb::Attribute((m ? m->getClass("LinkCounts") : LinkCounts_Class), "matches", eyedb::False, 0, dims);

  Supercontig_class->setAttributes(&attr[5], 5);

  delete attr[5];
  delete attr[6];
  delete attr[7];
  delete attr[8];
  delete attr[9];


  return Supercontig_class;
}

eyedb::Object *Supercontig_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Supercontig(cls, idr);
}

eyedb::Object *Supercontig_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Supercontig((const eyedb::Struct *)o, share);
}

static void Supercontig_init_p()
{
  Supercontig_Class = Supercontig_make();
  constructors_x[class_ind] = Supercontig_construct_x;
  constructors[class_ind] = Supercontig_construct;
  hash->insert("Supercontig", class_ind++);
}

static void Supercontig_init()
{
  Supercontig_make(Supercontig_Class);

  Supercontig_agritems = Supercontig_Class->getAttributes();
  Supercontig_idr_objsz = Supercontig_Class->getIDRObjectSize(&Supercontig_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Supercontig_Class, eyedb::True);
}

static eyedb::Status Supercontig_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Supercontig::Supercontig(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Sequence(_db, _dataspace, 1)
{
  initialize(_db);
}

Supercontig::Supercontig(const eyedb::Class *_cls, eyedb::Data _idr): Sequence((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Supercontig::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Supercontig") : Supercontig_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Supercontig::Supercontig(const Supercontig& x) : Sequence(x)
{
  userCopy(x);
}

Supercontig& Supercontig::operator=(const Supercontig& x)
{
  *(Sequence *)this = Sequence::operator=((const Sequence &)x);
  userCopy(x);
  return *this;
}

Supercontig::Supercontig(const eyedb::Struct *x, eyedb::Bool share) : Sequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Supercontig") : Supercontig_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Supercontig::Supercontig(const Supercontig *x, eyedb::Bool share) : Sequence(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Supercontig") : Supercontig_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Supercontig::regions(unsigned int a0, Region*_regions)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[5]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[5]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_oregions = _regions;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_oregions, 1, from);
  return status;
}

eyedb::Status Supercontig::regions_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[5]->setSize(this, from);
  return status;
}

const Region*Supercontig::regions(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Region *)__o;
     }
     __go = (Region *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Region*)__o;
}

Region*Supercontig::regions(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Region *)__o;
     }
     __go = (Region *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[5]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Region*)__o;
}

unsigned int Supercontig::regions_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[5]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

eyedb::Status Supercontig::nb_ctg(eyedblib::int32 _nb_ctg)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_nb_ctg, 1, 0);
  return status;
}

eyedblib::int32 Supercontig::nb_ctg(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Supercontig::nb_cseq(eyedblib::int32 _nb_cseq)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[7]->setValue(this, (eyedb::Data)&_nb_cseq, 1, 0);
  return status;
}

eyedblib::int32 Supercontig::nb_cseq(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[7]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Supercontig::clone_links(LinkCounts*_clone_links)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oclone_links = _clone_links;

  status = getClass()->getAttributes()[8]->setValue(this, (eyedb::Data)&_oclone_links, 1, 0);
  return status;
}

const LinkCounts*Supercontig::clone_links(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (LinkCounts *)__o;
     }
     __go = (LinkCounts *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (LinkCounts*)__o;
}

LinkCounts*Supercontig::clone_links(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[8]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (LinkCounts *)__o;
     }
     __go = (LinkCounts *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[8]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (LinkCounts*)__o;
}

eyedb::Status Supercontig::matches(LinkCounts*_matches)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_omatches = _matches;

  status = getClass()->getAttributes()[9]->setValue(this, (eyedb::Data)&_omatches, 1, 0);
  return status;
}

const LinkCounts*Supercontig::matches(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (LinkCounts *)__o;
     }
     __go = (LinkCounts *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (LinkCounts*)__o;
}

LinkCounts*Supercontig::matches(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[9]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (LinkCounts *)__o;
     }
     __go = (LinkCounts *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[9]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (LinkCounts*)__o;
}

static const eyedb::Attribute **SupercontigPair_agritems;
static eyedb::Size SupercontigPair_idr_objsz, SupercontigPair_idr_psize;

static eyedb::StructClass *SupercontigPair_make(eyedb::StructClass *SupercontigPair_class = 0, eyedb::Schema *m = 0)
{
  if (!SupercontigPair_class)
    return new eyedb::StructClass("SupercontigPair", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("Supercontig") : Supercontig_Class), "sctg0", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("Supercontig") : Supercontig_Class), "sctg1", eyedb::True, 0, dims);

  SupercontigPair_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return SupercontigPair_class;
}

eyedb::Object *SupercontigPair_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new SupercontigPair(cls, idr);
}

eyedb::Object *SupercontigPair_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new SupercontigPair((const eyedb::Struct *)o, share);
}

static void SupercontigPair_init_p()
{
  SupercontigPair_Class = SupercontigPair_make();
  constructors_x[class_ind] = SupercontigPair_construct_x;
  constructors[class_ind] = SupercontigPair_construct;
  hash->insert("SupercontigPair", class_ind++);
}

static void SupercontigPair_init()
{
  SupercontigPair_make(SupercontigPair_Class);

  SupercontigPair_agritems = SupercontigPair_Class->getAttributes();
  SupercontigPair_idr_objsz = SupercontigPair_Class->getIDRObjectSize(&SupercontigPair_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(SupercontigPair_Class, eyedb::True);
}

static eyedb::Status SupercontigPair_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

SupercontigPair::SupercontigPair(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

SupercontigPair::SupercontigPair(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void SupercontigPair::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("SupercontigPair") : SupercontigPair_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

SupercontigPair::SupercontigPair(const SupercontigPair& x) : Root(x)
{
  userCopy(x);
}

SupercontigPair& SupercontigPair::operator=(const SupercontigPair& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

SupercontigPair::SupercontigPair(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("SupercontigPair") : SupercontigPair_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

SupercontigPair::SupercontigPair(const SupercontigPair *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("SupercontigPair") : SupercontigPair_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status SupercontigPair::sctg0(Supercontig*_sctg0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osctg0 = _sctg0;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_osctg0, 1, 0);
  return status;
}

const Supercontig*SupercontigPair::sctg0(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

Supercontig*SupercontigPair::sctg0(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

eyedb::Status SupercontigPair::sctg0_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid SupercontigPair::sctg0_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status SupercontigPair::sctg1(Supercontig*_sctg1)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osctg1 = _sctg1;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_osctg1, 1, 0);
  return status;
}

const Supercontig*SupercontigPair::sctg1(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

Supercontig*SupercontigPair::sctg1(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Supercontig *)__o;
     }
     __go = (Supercontig *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Supercontig*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Supercontig *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Supercontig*)__o;
}

eyedb::Status SupercontigPair::sctg1_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid SupercontigPair::sctg1_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **Calculated_agritems;
static eyedb::Size Calculated_idr_objsz, Calculated_idr_psize;

static eyedb::StructClass *Calculated_make(eyedb::StructClass *Calculated_class = 0, eyedb::Schema *m = 0)
{
  if (!Calculated_class)
    return new eyedb::StructClass("Calculated", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("array<bag<SupercontigPair>*>") : array_class_bag_class_SupercontigPair_ref_Class), "clone_links", eyedb::False, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("array<bag<SupercontigPair>*>") : array_class_bag_class_SupercontigPair_ref_Class), "matches", eyedb::False, 0, dims);

  Calculated_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return Calculated_class;
}

eyedb::Object *Calculated_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Calculated(cls, idr);
}

eyedb::Object *Calculated_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Calculated((const eyedb::Struct *)o, share);
}

static void Calculated_init_p()
{
  Calculated_Class = Calculated_make();
  constructors_x[class_ind] = Calculated_construct_x;
  constructors[class_ind] = Calculated_construct;
  hash->insert("Calculated", class_ind++);
}

static void Calculated_init()
{
  Calculated_make(Calculated_Class);

  Calculated_agritems = Calculated_Class->getAttributes();
  Calculated_idr_objsz = Calculated_Class->getIDRObjectSize(&Calculated_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Calculated_Class, eyedb::True);
}

static eyedb::Status Calculated_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Calculated::Calculated(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Calculated::Calculated(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Calculated::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Calculated") : Calculated_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Calculated::Calculated(const Calculated& x) : Root(x)
{
  userCopy(x);
}

Calculated& Calculated::operator=(const Calculated& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Calculated::Calculated(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Calculated") : Calculated_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Calculated::Calculated(const Calculated *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Calculated") : Calculated_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Calculated::clone_links(eyedb::CollArray*_clone_links)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oclone_links = _clone_links;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_oclone_links, 1, 0);
  return status;
}

const eyedb::CollArray*Calculated::clone_links(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

const eyedb::CollBag*Calculated::clone_links_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::Status s;
  const eyedb::Collection* coll = clone_links(isnull, rs);

  if (!coll || (rs && *rs))
    return (eyedb::CollBag *)0;

  eyedb::CollBag *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (eyedb::CollBag *)0;}
  return tmp;
}

eyedb::CollArray*Calculated::clone_links(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

eyedb::CollBag*Calculated::clone_links_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::Status s;
  const eyedb::Collection* coll = clone_links(isnull, rs);

  if (!coll || (rs && *rs))
    return (eyedb::CollBag *)0;

  eyedb::CollBag *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (eyedb::CollBag *)0;}
  return tmp;
}

eyedb::Oid Calculated::clone_links_oidat(unsigned int ind, eyedb::Status *rs) const
{
  eyedb::Oid tmp;;
  eyedb::Status s;
  const eyedb::Collection* coll = clone_links((eyedb::Bool *)0, rs);

  if (!coll || (rs && *rs))
    return tmp;

  s = coll->asCollArray()->retrieveAt(ind, tmp);
  if (s && rs) *rs = s;
  return tmp;
}

eyedb::Status Calculated::setin_clone_links_at(int where, eyedb::CollBag*_clone_links, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("bag<SupercontigPair>"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _clone_links);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Calculated::setin_clone_links_at(int where, const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("bag<SupercontigPair>"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Calculated::unsetin_clone_links_at(int where)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Calculated::clone_links");

    }

  status = _coll->suppressAt(where);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Calculated::matches(eyedb::CollArray*_matches)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_omatches = _matches;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_omatches, 1, 0);
  return status;
}

const eyedb::CollArray*Calculated::matches(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

const eyedb::CollBag*Calculated::matches_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::Status s;
  const eyedb::Collection* coll = matches(isnull, rs);

  if (!coll || (rs && *rs))
    return (eyedb::CollBag *)0;

  eyedb::CollBag *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (eyedb::CollBag *)0;}
  return tmp;
}

eyedb::CollArray*Calculated::matches(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

eyedb::CollBag*Calculated::matches_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::Status s;
  const eyedb::Collection* coll = matches(isnull, rs);

  if (!coll || (rs && *rs))
    return (eyedb::CollBag *)0;

  eyedb::CollBag *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (eyedb::CollBag *)0;}
  return tmp;
}

eyedb::Oid Calculated::matches_oidat(unsigned int ind, eyedb::Status *rs) const
{
  eyedb::Oid tmp;;
  eyedb::Status s;
  const eyedb::Collection* coll = matches((eyedb::Bool *)0, rs);

  if (!coll || (rs && *rs))
    return tmp;

  s = coll->asCollArray()->retrieveAt(ind, tmp);
  if (s && rs) *rs = s;
  return tmp;
}

eyedb::Status Calculated::setin_matches_at(int where, eyedb::CollBag*_matches, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("bag<SupercontigPair>"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _matches);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Calculated::setin_matches_at(int where, const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("bag<SupercontigPair>"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Calculated::unsetin_matches_at(int where)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[3]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Calculated::matches");

    }

  status = _coll->suppressAt(where);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

static const eyedb::Attribute **Parameters_agritems;
static eyedb::Size Parameters_idr_objsz, Parameters_idr_psize;

static eyedb::StructClass *Parameters_make(eyedb::StructClass *Parameters_class = 0, eyedb::Schema *m = 0)
{
  if (!Parameters_class)
    return new eyedb::StructClass("Parameters", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "hole_size", eyedb::False, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("Calculated") : Calculated_Class), "calculated", eyedb::True, 0, dims);

  Parameters_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return Parameters_class;
}

eyedb::Object *Parameters_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Parameters(cls, idr);
}

eyedb::Object *Parameters_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Parameters((const eyedb::Struct *)o, share);
}

static void Parameters_init_p()
{
  Parameters_Class = Parameters_make();
  constructors_x[class_ind] = Parameters_construct_x;
  constructors[class_ind] = Parameters_construct;
  hash->insert("Parameters", class_ind++);
}

static void Parameters_init()
{
  Parameters_make(Parameters_Class);

  Parameters_agritems = Parameters_Class->getAttributes();
  Parameters_idr_objsz = Parameters_Class->getIDRObjectSize(&Parameters_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Parameters_Class, eyedb::True);
}

static eyedb::Status Parameters_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Parameters::Parameters(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Parameters::Parameters(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Parameters::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Parameters") : Parameters_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Parameters::Parameters(const Parameters& x) : Root(x)
{
  userCopy(x);
}

Parameters& Parameters::operator=(const Parameters& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Parameters::Parameters(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Parameters") : Parameters_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Parameters::Parameters(const Parameters *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Parameters") : Parameters_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Parameters::hole_size(eyedblib::int32 _hole_size)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_hole_size, 1, 0);
  return status;
}

eyedblib::int32 Parameters::hole_size(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Parameters::calculated(Calculated*_calculated)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocalculated = _calculated;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_ocalculated, 1, 0);
  return status;
}

const Calculated*Parameters::calculated(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Calculated *)__o;
     }
     __go = (Calculated *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Calculated*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Calculated *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Calculated*)__o;
}

Calculated*Parameters::calculated(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Calculated *)__o;
     }
     __go = (Calculated *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Calculated*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Calculated *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Calculated*)__o;
}

eyedb::Status Parameters::calculated_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Parameters::calculated_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **GroupName_agritems;
static eyedb::Size GroupName_idr_objsz, GroupName_idr_psize;

static eyedb::StructClass *GroupName_make(eyedb::StructClass *GroupName_class = 0, eyedb::Schema *m = 0)
{
  if (!GroupName_class)
    return new eyedb::StructClass("GroupName", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "comment", eyedb::False, 1, dims);
  delete[] dims;

  GroupName_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return GroupName_class;
}

eyedb::Object *GroupName_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new GroupName(cls, idr);
}

eyedb::Object *GroupName_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new GroupName((const eyedb::Struct *)o, share);
}

static void GroupName_init_p()
{
  GroupName_Class = GroupName_make();
  constructors_x[class_ind] = GroupName_construct_x;
  constructors[class_ind] = GroupName_construct;
  hash->insert("GroupName", class_ind++);
}

static void GroupName_init()
{
  GroupName_make(GroupName_Class);

  GroupName_agritems = GroupName_Class->getAttributes();
  GroupName_idr_objsz = GroupName_Class->getIDRObjectSize(&GroupName_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(GroupName_Class, eyedb::True);
}

static eyedb::Status GroupName_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "GroupName.name", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "GroupName.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

GroupName::GroupName(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

GroupName::GroupName(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void GroupName::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("GroupName") : GroupName_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

GroupName::GroupName(const GroupName& x) : Root(x)
{
  userCopy(x);
}

GroupName& GroupName::operator=(const GroupName& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

GroupName::GroupName(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("GroupName") : GroupName_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

GroupName::GroupName(const GroupName *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("GroupName") : GroupName_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status GroupName::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status GroupName::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string GroupName::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char GroupName::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status GroupName::comment(const std::string &_comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _comment.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_comment.c_str(), len, 0);
  return status;

}

eyedb::Status GroupName::comment(unsigned int a0, char _comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_comment, 1, from);
  return status;
}

std::string GroupName::comment(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char GroupName::comment(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **SupercontigSet_agritems;
static eyedb::Size SupercontigSet_idr_objsz, SupercontigSet_idr_psize;

static eyedb::StructClass *SupercontigSet_make(eyedb::StructClass *SupercontigSet_class = 0, eyedb::Schema *m = 0)
{
  if (!SupercontigSet_class)
    return new eyedb::StructClass("SupercontigSet", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[3];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("set<Supercontig*>") : set_class_Supercontig_ref_Class), "s", eyedb::False, 0, dims);

  SupercontigSet_class->setAttributes(&attr[2], 1);

  delete attr[2];


  return SupercontigSet_class;
}

eyedb::Object *SupercontigSet_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new SupercontigSet(cls, idr);
}

eyedb::Object *SupercontigSet_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new SupercontigSet((const eyedb::Struct *)o, share);
}

static void SupercontigSet_init_p()
{
  SupercontigSet_Class = SupercontigSet_make();
  constructors_x[class_ind] = SupercontigSet_construct_x;
  constructors[class_ind] = SupercontigSet_construct;
  hash->insert("SupercontigSet", class_ind++);
}

static void SupercontigSet_init()
{
  SupercontigSet_make(SupercontigSet_Class);

  SupercontigSet_agritems = SupercontigSet_Class->getAttributes();
  SupercontigSet_idr_objsz = SupercontigSet_Class->getIDRObjectSize(&SupercontigSet_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(SupercontigSet_Class, eyedb::True);
}

static eyedb::Status SupercontigSet_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::CollAttrImpl(db, cls, "SupercontigSet.s", eyedb::True, dataspace, eyedb::IndexImpl::BTree, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

SupercontigSet::SupercontigSet(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

SupercontigSet::SupercontigSet(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void SupercontigSet::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("SupercontigSet") : SupercontigSet_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

SupercontigSet::SupercontigSet(const SupercontigSet& x) : Root(x)
{
  userCopy(x);
}

SupercontigSet& SupercontigSet::operator=(const SupercontigSet& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

SupercontigSet::SupercontigSet(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("SupercontigSet") : SupercontigSet_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

SupercontigSet::SupercontigSet(const SupercontigSet *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("SupercontigSet") : SupercontigSet_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status SupercontigSet::s(eyedb::CollSet*_s)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_os = _s;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_os, 1, 0);
  return status;
}

const eyedb::CollSet*SupercontigSet::s(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollSet*)__o;
}

eyedb::CollSet*SupercontigSet::s(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollSet*)__o;
}

eyedb::Status SupercontigSet::addto_s(Supercontig*_s, eyedb::Bool noDup, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollSet(db, "", db->getSchema()->getClass("Supercontig"), eyedb::True, idximpl);
       }
    }

  status = _coll->insert(_s, noDup);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status SupercontigSet::addto_s(const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollSet(db, "", db->getSchema()->getClass("Supercontig"), eyedb::True, idximpl);
       }
    }

  status = _coll->insert(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status SupercontigSet::rmvfrom_s(Supercontig*_s, eyedb::Bool checkFirst)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute SupercontigSet::s");

    }

  status = _coll->suppress(_s, checkFirst);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status SupercontigSet::rmvfrom_s(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute SupercontigSet::s");

    }

  status = _coll->suppress(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

static const eyedb::Attribute **Group_agritems;
static eyedb::Size Group_idr_objsz, Group_idr_psize;

static eyedb::StructClass *Group_make(eyedb::StructClass *Group_class = 0, eyedb::Schema *m = 0)
{
  if (!Group_class)
    return new eyedb::StructClass("Group", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[7];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("set<Supercontig*>") : set_class_Supercontig_ref_Class), "sctgs", eyedb::False, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("GroupName") : GroupName_Class), "name", eyedb::True, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("array<SupercontigSet*>") : array_class_SupercontigSet_ref_Class), "length_counts", eyedb::False, 0, dims);

  dims = 0;
  attr[5] = new eyedb::Attribute((m ? m->getClass("array<SupercontigSet*>") : array_class_SupercontigSet_ref_Class), "ctg_counts", eyedb::False, 0, dims);

  dims = 0;
  attr[6] = new eyedb::Attribute((m ? m->getClass("array<SupercontigSet*>") : array_class_SupercontigSet_ref_Class), "cseq_counts", eyedb::False, 0, dims);

  Group_class->setAttributes(&attr[2], 5);

  delete attr[2];
  delete attr[3];
  delete attr[4];
  delete attr[5];
  delete attr[6];


  return Group_class;
}

eyedb::Object *Group_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Group(cls, idr);
}

eyedb::Object *Group_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Group((const eyedb::Struct *)o, share);
}

static void Group_init_p()
{
  Group_Class = Group_make();
  constructors_x[class_ind] = Group_construct_x;
  constructors[class_ind] = Group_construct;
  hash->insert("Group", class_ind++);
}

static void Group_init()
{
  Group_make(Group_Class);

  Group_agritems = Group_Class->getAttributes();
  Group_idr_objsz = Group_Class->getIDRObjectSize(&Group_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Group_Class, eyedb::True);
}

static eyedb::Status Group_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

Group::Group(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Group::Group(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Group::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Group") : Group_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Group::Group(const Group& x) : Root(x)
{
  userCopy(x);
}

Group& Group::operator=(const Group& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Group::Group(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Group") : Group_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Group::Group(const Group *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Group") : Group_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Group::sctgs(eyedb::CollSet*_sctgs)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osctgs = _sctgs;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_osctgs, 1, 0);
  return status;
}

const eyedb::CollSet*Group::sctgs(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollSet*)__o;
}

eyedb::CollSet*Group::sctgs(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollSet*)__o;
}

eyedb::Status Group::addto_sctgs(Supercontig*_sctgs, eyedb::Bool noDup, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollSet(db, "", db->getSchema()->getClass("Supercontig"), eyedb::True, idximpl);
       }
    }

  status = _coll->insert(_sctgs, noDup);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::addto_sctgs(const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollSet(db, "", db->getSchema()->getClass("Supercontig"), eyedb::True, idximpl);
       }
    }

  status = _coll->insert(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::rmvfrom_sctgs(Supercontig*_sctgs, eyedb::Bool checkFirst)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Group::sctgs");

    }

  status = _coll->suppress(_sctgs, checkFirst);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::rmvfrom_sctgs(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollSet *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[2]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Group::sctgs");

    }

  status = _coll->suppress(_oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::name(GroupName*_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oname = _name;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_oname, 1, 0);
  return status;
}

const GroupName*Group::name(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (GroupName *)__o;
     }
     __go = (GroupName *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (GroupName*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (GroupName *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (GroupName*)__o;
}

GroupName*Group::name(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (GroupName *)__o;
     }
     __go = (GroupName *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (GroupName*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[3]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (GroupName *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[3]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (GroupName*)__o;
}

eyedb::Status Group::name_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Group::name_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Group::length_counts(eyedb::CollArray*_length_counts)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_olength_counts = _length_counts;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_olength_counts, 1, 0);
  return status;
}

const eyedb::CollArray*Group::length_counts(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

const SupercontigSet*Group::length_counts_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::Status s;
  const eyedb::Collection* coll = length_counts(isnull, rs);

  if (!coll || (rs && *rs))
    return (SupercontigSet *)0;

  SupercontigSet *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (SupercontigSet *)0;}
  return tmp;
}

eyedb::CollArray*Group::length_counts(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

SupercontigSet*Group::length_counts_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::Status s;
  const eyedb::Collection* coll = length_counts(isnull, rs);

  if (!coll || (rs && *rs))
    return (SupercontigSet *)0;

  SupercontigSet *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (SupercontigSet *)0;}
  return tmp;
}

eyedb::Oid Group::length_counts_oidat(unsigned int ind, eyedb::Status *rs) const
{
  eyedb::Oid tmp;;
  eyedb::Status s;
  const eyedb::Collection* coll = length_counts((eyedb::Bool *)0, rs);

  if (!coll || (rs && *rs))
    return tmp;

  s = coll->asCollArray()->retrieveAt(ind, tmp);
  if (s && rs) *rs = s;
  return tmp;
}

eyedb::Status Group::setin_length_counts_at(int where, SupercontigSet*_length_counts, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[4]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("SupercontigSet"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _length_counts);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::setin_length_counts_at(int where, const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[4]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("SupercontigSet"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::unsetin_length_counts_at(int where)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[4]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Group::length_counts");

    }

  status = _coll->suppressAt(where);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::ctg_counts(eyedb::CollArray*_ctg_counts)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_octg_counts = _ctg_counts;

  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_octg_counts, 1, 0);
  return status;
}

const eyedb::CollArray*Group::ctg_counts(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

const SupercontigSet*Group::ctg_counts_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::Status s;
  const eyedb::Collection* coll = ctg_counts(isnull, rs);

  if (!coll || (rs && *rs))
    return (SupercontigSet *)0;

  SupercontigSet *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (SupercontigSet *)0;}
  return tmp;
}

eyedb::CollArray*Group::ctg_counts(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

SupercontigSet*Group::ctg_counts_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::Status s;
  const eyedb::Collection* coll = ctg_counts(isnull, rs);

  if (!coll || (rs && *rs))
    return (SupercontigSet *)0;

  SupercontigSet *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (SupercontigSet *)0;}
  return tmp;
}

eyedb::Oid Group::ctg_counts_oidat(unsigned int ind, eyedb::Status *rs) const
{
  eyedb::Oid tmp;;
  eyedb::Status s;
  const eyedb::Collection* coll = ctg_counts((eyedb::Bool *)0, rs);

  if (!coll || (rs && *rs))
    return tmp;

  s = coll->asCollArray()->retrieveAt(ind, tmp);
  if (s && rs) *rs = s;
  return tmp;
}

eyedb::Status Group::setin_ctg_counts_at(int where, SupercontigSet*_ctg_counts, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[5]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("SupercontigSet"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _ctg_counts);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::setin_ctg_counts_at(int where, const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[5]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("SupercontigSet"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::unsetin_ctg_counts_at(int where)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[5]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[5]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Group::ctg_counts");

    }

  status = _coll->suppressAt(where);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[5]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::cseq_counts(eyedb::CollArray*_cseq_counts)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ocseq_counts = _cseq_counts;

  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_ocseq_counts, 1, 0);
  return status;
}

const eyedb::CollArray*Group::cseq_counts(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

const SupercontigSet*Group::cseq_counts_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::Status s;
  const eyedb::Collection* coll = cseq_counts(isnull, rs);

  if (!coll || (rs && *rs))
    return (SupercontigSet *)0;

  SupercontigSet *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (SupercontigSet *)0;}
  return tmp;
}

eyedb::CollArray*Group::cseq_counts(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return (eyedb::CollArray*)__o;
}

SupercontigSet*Group::cseq_counts_at(unsigned int ind, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::Status s;
  const eyedb::Collection* coll = cseq_counts(isnull, rs);

  if (!coll || (rs && *rs))
    return (SupercontigSet *)0;

  SupercontigSet *tmp = 0;
  s = coll->asCollArray()->retrieveAt(ind, (eyedb::Object*&)tmp);
  if (s) {if (rs) *rs = s; return (SupercontigSet *)0;}
  return tmp;
}

eyedb::Oid Group::cseq_counts_oidat(unsigned int ind, eyedb::Status *rs) const
{
  eyedb::Oid tmp;;
  eyedb::Status s;
  const eyedb::Collection* coll = cseq_counts((eyedb::Bool *)0, rs);

  if (!coll || (rs && *rs))
    return tmp;

  s = coll->asCollArray()->retrieveAt(ind, tmp);
  if (s && rs) *rs = s;
  return tmp;
}

eyedb::Status Group::setin_cseq_counts_at(int where, SupercontigSet*_cseq_counts, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[6]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("SupercontigSet"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _cseq_counts);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::setin_cseq_counts_at(int where, const eyedb::Oid &_oid, const eyedb::IndexImpl *idximpl)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[6]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
       {
         _coll = new eyedb::CollArray(db, "", db->getSchema()->getClass("SupercontigSet"), eyedb::True, idximpl);
       }
    }

  status = _coll->insertAt(where, _oid);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

eyedb::Status Group::unsetin_cseq_counts_at(int where)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::CollArray *_coll;
  eyedb::Bool _not_set = eyedb::False;
  eyedb::Size from = 0;

  status = getClass()->getAttributes()[6]->getValue(this, (eyedb::Data *)&_coll, 1, from);
  if (status)
    return status;

  if (!_coll)
    {
     _not_set = eyedb::True;
     eyedb::Oid _coll_oid;
     status = getClass()->getAttributes()[6]->getOid(this, &_coll_oid, 1, from);
     if (status)
      return status;

     if (_coll_oid.isValid())
       {
       status = db->loadObject(&_coll_oid, (eyedb::Object **)&_coll);
       if (status)
        return status;
       }
     else
        return eyedb::Exception::make(eyedb::IDB_ERROR, "no valid collection in attribute Group::cseq_counts");

    }

  status = _coll->suppressAt(where);
  if (status || !_not_set)
    return status;


  status = getClass()->getAttributes()[6]->setValue(this, (eyedb::Data)&_coll, 1, from);
     _coll->release();

  return status;
}

static const eyedb::Attribute **StageType_agritems;
static eyedb::Size StageType_idr_objsz, StageType_idr_psize;

static eyedb::StructClass *StageType_make(eyedb::StructClass *StageType_class = 0, eyedb::Schema *m = 0)
{
  if (!StageType_class)
    return new eyedb::StructClass("StageType", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "comment", eyedb::False, 1, dims);
  delete[] dims;

  StageType_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return StageType_class;
}

eyedb::Object *StageType_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new StageType(cls, idr);
}

eyedb::Object *StageType_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new StageType((const eyedb::Struct *)o, share);
}

static void StageType_init_p()
{
  StageType_Class = StageType_make();
  constructors_x[class_ind] = StageType_construct_x;
  constructors[class_ind] = StageType_construct;
  hash->insert("StageType", class_ind++);
}

static void StageType_init()
{
  StageType_make(StageType_Class);

  StageType_agritems = StageType_Class->getAttributes();
  StageType_idr_objsz = StageType_Class->getIDRObjectSize(&StageType_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(StageType_Class, eyedb::True);
}

static eyedb::Status StageType_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "StageType.name", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "StageType.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

StageType::StageType(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

StageType::StageType(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void StageType::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("StageType") : StageType_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

StageType::StageType(const StageType& x) : Root(x)
{
  userCopy(x);
}

StageType& StageType::operator=(const StageType& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

StageType::StageType(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("StageType") : StageType_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

StageType::StageType(const StageType *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("StageType") : StageType_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status StageType::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status StageType::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string StageType::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char StageType::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status StageType::comment(const std::string &_comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _comment.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_comment.c_str(), len, 0);
  return status;

}

eyedb::Status StageType::comment(unsigned int a0, char _comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_comment, 1, from);
  return status;
}

std::string StageType::comment(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char StageType::comment(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **Stage_agritems;
static eyedb::Size Stage_idr_objsz, Stage_idr_psize;

static eyedb::StructClass *Stage_make(eyedb::StructClass *Stage_class = 0, eyedb::Schema *m = 0)
{
  if (!Stage_class)
    return new eyedb::StructClass("Stage", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "id", eyedb::False, 0, dims);

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("Group") : Group_Class), "groups", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("StageType") : StageType_Class), "stage_type", eyedb::True, 0, dims);

  Stage_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return Stage_class;
}

eyedb::Object *Stage_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Stage(cls, idr);
}

eyedb::Object *Stage_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Stage((const eyedb::Struct *)o, share);
}

static void Stage_init_p()
{
  Stage_Class = Stage_make();
  constructors_x[class_ind] = Stage_construct_x;
  constructors[class_ind] = Stage_construct;
  hash->insert("Stage", class_ind++);
}

static void Stage_init()
{
  Stage_make(Stage_Class);

  Stage_agritems = Stage_Class->getAttributes();
  Stage_idr_objsz = Stage_Class->getIDRObjectSize(&Stage_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Stage_Class, eyedb::True);
}

static eyedb::Status Stage_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "Stage.id", eyedb::True, eyedb::False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "Stage.id", eyedb::True);
  cls->add(comp->getInd(), comp);

  comp = new eyedb::NotNullConstraint(db, cls, "Stage.id", eyedb::True);
  cls->add(comp->getInd(), comp);

  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::CollAttrImpl(db, cls, "Stage.groups.sctgs", eyedb::True, dataspace, eyedb::IndexImpl::BTree, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Stage::Stage(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Stage::Stage(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Stage::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Stage") : Stage_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Stage::Stage(const Stage& x) : Root(x)
{
  userCopy(x);
}

Stage& Stage::operator=(const Stage& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Stage::Stage(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Stage") : Stage_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Stage::Stage(const Stage *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Stage") : Stage_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Stage::id(eyedblib::int32 _id)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_id, 1, 0);
  return status;
}

eyedblib::int32 Stage::id(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Stage::groups(unsigned int a0, Group*_groups)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  eyedb::Object *_ogroups = _groups;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_ogroups, 1, from);
  return status;
}

eyedb::Status Stage::groups_cnt(unsigned int a0)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;
  status = getClass()->getAttributes()[3]->setSize(this, from);
  return status;
}

const Group*Stage::groups(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Group *)__o;
     }
     __go = (Group *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Group*)__o;
}

Group*Stage::groups(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Group *)__o;
     }
     __go = (Group *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (Group*)__o;
}

unsigned int Stage::groups_cnt(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Size size;
  eyedb::Status s;
  s = getClass()->getAttributes()[3]->getSize(this, size);
  if (s) {if (rs) *rs = s; return 0;}
  return (int)size;
}

eyedb::Status Stage::stage_type(StageType*_stage_type)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_ostage_type = _stage_type;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_ostage_type, 1, 0);
  return status;
}

const StageType*Stage::stage_type(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (StageType *)__o;
     }
     __go = (StageType *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (StageType*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (StageType *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (StageType*)__o;
}

StageType*Stage::stage_type(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (StageType *)__o;
     }
     __go = (StageType *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[4]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (StageType*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[4]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (StageType *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[4]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (StageType*)__o;
}

eyedb::Status Stage::stage_type_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Stage::stage_type_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

static const eyedb::Attribute **Algorithm_agritems;
static eyedb::Size Algorithm_idr_objsz, Algorithm_idr_psize;

static eyedb::StructClass *Algorithm_make(eyedb::StructClass *Algorithm_class = 0, eyedb::Schema *m = 0)
{
  if (!Algorithm_class)
    return new eyedb::StructClass("Algorithm", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[4];
  int *dims;

  dims = new int[1];
  dims[0] = -1;
  attr[2] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "name", eyedb::False, 1, dims);
  delete[] dims;

  dims = new int[1];
  dims[0] = -1;
  attr[3] = new eyedb::Attribute((m ? m->getClass("char") : eyedb::Char_Class), "comment", eyedb::False, 1, dims);
  delete[] dims;

  Algorithm_class->setAttributes(&attr[2], 2);

  delete attr[2];
  delete attr[3];


  return Algorithm_class;
}

eyedb::Object *Algorithm_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Algorithm(cls, idr);
}

eyedb::Object *Algorithm_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Algorithm((const eyedb::Struct *)o, share);
}

static void Algorithm_init_p()
{
  Algorithm_Class = Algorithm_make();
  constructors_x[class_ind] = Algorithm_construct_x;
  constructors[class_ind] = Algorithm_construct;
  hash->insert("Algorithm", class_ind++);
}

static void Algorithm_init()
{
  Algorithm_make(Algorithm_Class);

  Algorithm_agritems = Algorithm_Class->getAttributes();
  Algorithm_idr_objsz = Algorithm_Class->getIDRObjectSize(&Algorithm_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Algorithm_Class, eyedb::True);
}

static eyedb::Status Algorithm_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::HashIndex(db, cls, "Algorithm.name", eyedb::True, eyedb::True, dataspace, 0, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  comp = new eyedb::UniqueConstraint(db, cls, "Algorithm.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  comp = new eyedb::NotNullConstraint(db, cls, "Algorithm.name", eyedb::True);
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Algorithm::Algorithm(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Algorithm::Algorithm(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Algorithm::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Algorithm") : Algorithm_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Algorithm::Algorithm(const Algorithm& x) : Root(x)
{
  userCopy(x);
}

Algorithm& Algorithm::operator=(const Algorithm& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Algorithm::Algorithm(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Algorithm") : Algorithm_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Algorithm::Algorithm(const Algorithm *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Algorithm") : Algorithm_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Algorithm::name(const std::string &_name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _name.size() + 1;

  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[2]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)_name.c_str(), len, 0);
  return status;

}

eyedb::Status Algorithm::name(unsigned int a0, char _name)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[2]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[2]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_name, 1, from);
  return status;
}

std::string Algorithm::name(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Algorithm::name(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status Algorithm::comment(const std::string &_comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size size;
  eyedb::Size len = _comment.size() + 1;

  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size != len)
    status = getClass()->getAttributes()[3]->setSize(this, len);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)_comment.c_str(), len, 0);
  return status;

}

eyedb::Status Algorithm::comment(unsigned int a0, char _comment)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Size size;
  status = getClass()->getAttributes()[3]->getSize(this, size);
  if (status)
    return status;

  if (size <= from)
    status = getClass()->getAttributes()[3]->setSize(this, from+1);
  if (status)
    return status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_comment, 1, from);
  return status;
}

std::string Algorithm::comment(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Data data;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&data, eyedb::Attribute::directAccess, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  if (!data) data = nulldata;
  return (const char *)data;
}

char Algorithm::comment(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  char __tmp = 0;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **MatchSide_agritems;
static eyedb::Size MatchSide_idr_objsz, MatchSide_idr_psize;

static eyedb::StructClass *MatchSide_make(eyedb::StructClass *MatchSide_class = 0, eyedb::Schema *m = 0)
{
  if (!MatchSide_class)
    return new eyedb::StructClass("MatchSide", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("ContinuousSequence") : ContinuousSequence_Class), "sequence", eyedb::True, 0, dims);

  dims = 0;
  attr[3] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "start", eyedb::False, 0, dims);

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("int") : eyedb::Int32_Class), "stop", eyedb::False, 0, dims);

  MatchSide_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return MatchSide_class;
}

eyedb::Object *MatchSide_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new MatchSide(cls, idr);
}

eyedb::Object *MatchSide_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new MatchSide((const eyedb::Struct *)o, share);
}

static void MatchSide_init_p()
{
  MatchSide_Class = MatchSide_make();
  constructors_x[class_ind] = MatchSide_construct_x;
  constructors[class_ind] = MatchSide_construct;
  hash->insert("MatchSide", class_ind++);
}

static void MatchSide_init()
{
  MatchSide_make(MatchSide_Class);

  MatchSide_agritems = MatchSide_Class->getAttributes();
  MatchSide_idr_objsz = MatchSide_Class->getIDRObjectSize(&MatchSide_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(MatchSide_Class, eyedb::True);
}

static eyedb::Status MatchSide_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  return eyedb::Success;
}

MatchSide::MatchSide(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

MatchSide::MatchSide(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void MatchSide::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("MatchSide") : MatchSide_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

MatchSide::MatchSide(const MatchSide& x) : Root(x)
{
  userCopy(x);
}

MatchSide& MatchSide::operator=(const MatchSide& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

MatchSide::MatchSide(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("MatchSide") : MatchSide_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

MatchSide::MatchSide(const MatchSide *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("MatchSide") : MatchSide_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status MatchSide::sequence(ContinuousSequence*_sequence)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_osequence = _sequence;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_osequence, 1, 0);
  return status;
}

const ContinuousSequence*MatchSide::sequence(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

ContinuousSequence*MatchSide::sequence(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (ContinuousSequence *)__o;
     }
     __go = (ContinuousSequence *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (ContinuousSequence*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (ContinuousSequence *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (ContinuousSequence*)__o;
}

eyedb::Status MatchSide::sequence_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid MatchSide::sequence_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status MatchSide::start(eyedblib::int32 _start)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_start, 1, 0);
  return status;
}

eyedblib::int32 MatchSide::start(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

eyedb::Status MatchSide::stop(eyedblib::int32 _stop)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_stop, 1, 0);
  return status;
}

eyedblib::int32 MatchSide::stop(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedblib::int32 __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static const eyedb::Attribute **Match_agritems;
static eyedb::Size Match_idr_objsz, Match_idr_psize;

static eyedb::StructClass *Match_make(eyedb::StructClass *Match_class = 0, eyedb::Schema *m = 0)
{
  if (!Match_class)
    return new eyedb::StructClass("Match", (m ? m->getClass("struct") : eyedb::Struct_Class));
  eyedb::Attribute *attr[5];
  int *dims;

  dims = 0;
  attr[2] = new eyedb::Attribute((m ? m->getClass("Algorithm") : Algorithm_Class), "algorithm", eyedb::True, 0, dims);

  dims = new int[1];
  dims[0] = 2;
  attr[3] = new eyedb::Attribute((m ? m->getClass("MatchSide") : MatchSide_Class), "sides", eyedb::False, 1, dims);
  delete[] dims;

  dims = 0;
  attr[4] = new eyedb::Attribute((m ? m->getClass("float") : eyedb::Float_Class), "id_ratio", eyedb::False, 0, dims);

  Match_class->setAttributes(&attr[2], 3);

  delete attr[2];
  delete attr[3];
  delete attr[4];


  return Match_class;
}

eyedb::Object *Match_construct_x(const eyedb::Class *cls, eyedb::Data idr)
{
  return new Match(cls, idr);
}

eyedb::Object *Match_construct(const eyedb::Object *o, eyedb::Bool share)
{
  return new Match((const eyedb::Struct *)o, share);
}

static void Match_init_p()
{
  Match_Class = Match_make();
  constructors_x[class_ind] = Match_construct_x;
  constructors[class_ind] = Match_construct;
  hash->insert("Match", class_ind++);
}

static void Match_init()
{
  Match_make(Match_Class);

  Match_agritems = Match_Class->getAttributes();
  Match_idr_objsz = Match_Class->getIDRObjectSize(&Match_idr_psize, 0);

  eyedb::ObjectPeer::setUnrealizable(Match_Class, eyedb::True);
}

static eyedb::Status Match_attrcomp_realize(eyedb::Database *db, eyedb::Class *cls)
{
  eyedb::AttributeComponent *comp;
  const eyedb::Dataspace *dataspace;
  eyedb::ClassComponent *clcomp;
  eyedb::Status status;
  int *impl_hints;
  impl_hints = new int[8];
  impl_hints[0] = 0;
  impl_hints[1] = 0;
  impl_hints[2] = 0;
  impl_hints[3] = 0;
  impl_hints[4] = 0;
  impl_hints[5] = 0;
  impl_hints[6] = 0;
  impl_hints[7] = 0;
  dataspace = 0;;
  comp = new eyedb::BTreeIndex(db, cls, "Match.sides.sequence", eyedb::True, eyedb::False, dataspace, 0, impl_hints, 8);
  delete [] impl_hints;
  cls->add(comp->getInd(), comp);

  return eyedb::Success;
}

Match::Match(eyedb::Database *_db, const eyedb::Dataspace *_dataspace) : Root(_db, _dataspace, 1)
{
  initialize(_db);
}

Match::Match(const eyedb::Class *_cls, eyedb::Data _idr): Root((eyedb::Database *)0, (const eyedb::Dataspace *)0, 1)
{
  setClass((eyedb::Class *)_cls);

  eyedb::Size idr_psize;
  eyedb::Size idr_tsize = getClass()->getIDRObjectSize(&idr_psize);
  if (_idr)
    idr->setIDR(idr_tsize, _idr);
  else
    {
      idr->setIDR(idr_tsize);
      memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
    }
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

void Match::initialize(eyedb::Database *_db)
{
  setClass((_db ? _db->getSchema()->getClass("Match") : Match_Class));

  eyedb::Size idr_psize;
  idr->setIDR(getClass()->getIDRObjectSize(&idr_psize));
  memset(idr->getIDR() + IDB_OBJ_HEAD_SIZE, 0, idr->getSize() - IDB_OBJ_HEAD_SIZE);
  headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
  eyedb::ClassPeer::newObjRealize(getClass(), this);
  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userInitialize();
}

Match::Match(const Match& x) : Root(x)
{
  userCopy(x);
}

Match& Match::operator=(const Match& x)
{
  *(Root *)this = Root::operator=((const Root &)x);
  userCopy(x);
  return *this;
}

Match::Match(const eyedb::Struct *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Match") : Match_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

Match::Match(const Match *x, eyedb::Bool share) : Root(x, share, 1)
{
  setClass((db ? db->getSchema()->getClass("Match") : Match_Class));

  eyedb::Size idr_psize;
  getClass()->getIDRObjectSize(&idr_psize);
  if (!share)
    {
      headerCode(eyedb::_Struct_Type, idr_psize, IDB_XINFO_LOCAL_OBJ);
      eyedb::ClassPeer::newObjRealize(getClass(), this);
    }

  eyedb::ObjectPeer::setGRTObject(this, eyedb::True);
  userCopy(*x);
}

eyedb::Status Match::algorithm(Algorithm*_algorithm)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  eyedb::Object *_oalgorithm = _algorithm;

  status = getClass()->getAttributes()[2]->setValue(this, (eyedb::Data)&_oalgorithm, 1, 0);
  return status;
}

const Algorithm*Match::algorithm(eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Algorithm *)__o;
     }
     __go = (Algorithm *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Algorithm*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Algorithm *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Algorithm*)__o;
}

Algorithm*Match::algorithm(eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getValue(this, (eyedb::Data *)&__o, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (Algorithm *)__o;
     }
     __go = (Algorithm *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;
       s = getClass()->getAttributes()[2]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, 0);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
     return (Algorithm*)__o;
    }

  eyedb::Bool wasnull = (!__o ? eyedb::True : eyedb::False);
  if (!__o && db)
    {
      eyedb::Oid toid;
      s = getClass()->getAttributes()[2]->getOid(this, &toid, 1, 0);
      if (s) {if (rs) *rs = s; return 0;}
      if (toid.isValid())
        {
          s = db->loadObject(&toid, &__o);
          if (s) {if (rs) *rs = s; return 0;}
          if (!eyedb::ObjectPeer::isGRTObject(__o))
           {
             __go = (Algorithm *)make_object(__o, eyedb::False);
             if (__go) __o = __go;
           }
        }
    }

  if (__o && wasnull)
    {
     s = getClass()->getAttributes()[2]->setValue((eyedb::Agregat *)this, (eyedb::Data)&__o, 1, 0);
     if (s) {if (rs) *rs = s; return 0;}
     __o->release();
    }
  return (Algorithm*)__o;
}

eyedb::Status Match::algorithm_oid(const eyedb::Oid &_oid)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[2]->setOid(this, &_oid, 1, 0, oid_check);
  return status;
}

eyedb::Oid Match::algorithm_oid(eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Oid __tmp;
  eyedb::Status s;

  s = getClass()->getAttributes()[2]->getOid(this, &__tmp, 1, 0);
  if (s) {if (rs) *rs = s; return nulloid;}

  return __tmp;
}

eyedb::Status Match::sides(unsigned int a0, MatchSide*_sides)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;
  eyedb::Size from = a0;

  eyedb::Object *_osides = _sides;

  status = getClass()->getAttributes()[3]->setValue(this, (eyedb::Data)&_osides, 1, from);
  return status;
}

const MatchSide*Match::sides(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) const 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (MatchSide *)__o;
     }
     __go = (MatchSide *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (MatchSide*)__o;
}

MatchSide*Match::sides(unsigned int a0, eyedb::Bool *isnull, eyedb::Status *rs) 
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Object *__o = 0, *__go;
  eyedb::Status s;
  eyedb::Size from = a0;

  s = getClass()->getAttributes()[3]->getValue(this, (eyedb::Data *)&__o, 1, from, isnull);
  if (s) {if (rs) *rs = s; return 0;}

  if (__o)
    {
     if (eyedb::ObjectPeer::isGRTObject(__o)) {
       return (MatchSide *)__o;
     }
     __go = (MatchSide *)make_object(__o, eyedb::False);
     if (__go)
      {
       __o = __go;;
       s = getClass()->getAttributes()[3]->setValue((Agregat *)this, (eyedb::Data)&__o, 1, from);
       eyedb::ObjectPeer::decrRefCount(__o);
       if (s) {if (rs) *rs = s; return 0;}
      }
    }
  return (MatchSide*)__o;
}

eyedb::Status Match::id_ratio(double _id_ratio)
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  eyedb::Status status;

  status = getClass()->getAttributes()[4]->setValue(this, (eyedb::Data)&_id_ratio, 1, 0);
  return status;
}

double Match::id_ratio(eyedb::Bool *isnull, eyedb::Status *rs) const
{
  eyedb::gbxAutoGarbSuspender _gbxsusp_;
  double __tmp = 0;
  eyedb::Status s;

  s = getClass()->getAttributes()[4]->getValue(this, (eyedb::Data *)&__tmp, 1, 0, isnull);
  if (s) {if (rs) *rs = s; return 0;}
  return __tmp;
}

static eyedb::CollBagClass *bag_class_SupercontigPair_make(eyedb::CollBagClass *cls = 0, eyedb::Schema *m = 0)
{
  if (!cls)
    {
      cls = new eyedb::CollBagClass((m ? m->getClass("SupercontigPair") : SupercontigPair_Class), eyedb::False);
      eyedb::ClassPeer::setMType(cls, eyedb::Class::System);
    }
  return cls;
}

static void bag_class_SupercontigPair_init_p()
{
  bag_class_SupercontigPair_Class = bag_class_SupercontigPair_make();
}

static eyedb::CollArrayClass *array_class_bag_class_SupercontigPair_ref_make(eyedb::CollArrayClass *cls = 0, eyedb::Schema *m = 0)
{
  if (!cls)
    {
      cls = new eyedb::CollArrayClass((m ? m->getClass("bag<SupercontigPair>") : bag_class_SupercontigPair_Class), eyedb::True);
      eyedb::ClassPeer::setMType(cls, eyedb::Class::System);
    }
  return cls;
}

static void array_class_bag_class_SupercontigPair_ref_init_p()
{
  array_class_bag_class_SupercontigPair_ref_Class = array_class_bag_class_SupercontigPair_ref_make();
}

static eyedb::CollSetClass *set_class_Supercontig_ref_make(eyedb::CollSetClass *cls = 0, eyedb::Schema *m = 0)
{
  if (!cls)
    {
      cls = new eyedb::CollSetClass((m ? m->getClass("Supercontig") : Supercontig_Class), eyedb::True);
      eyedb::ClassPeer::setMType(cls, eyedb::Class::System);
    }
  return cls;
}

static void set_class_Supercontig_ref_init_p()
{
  set_class_Supercontig_ref_Class = set_class_Supercontig_ref_make();
}

static eyedb::CollArrayClass *array_class_SupercontigSet_ref_make(eyedb::CollArrayClass *cls = 0, eyedb::Schema *m = 0)
{
  if (!cls)
    {
      cls = new eyedb::CollArrayClass((m ? m->getClass("SupercontigSet") : SupercontigSet_Class), eyedb::True);
      eyedb::ClassPeer::setMType(cls, eyedb::Class::System);
    }
  return cls;
}

static void array_class_SupercontigSet_ref_init_p()
{
  array_class_SupercontigSet_ref_Class = array_class_SupercontigSet_ref_make();
}

static const char not_exit_msg[] = "class does not exist";
static const char differ_msg[] = "class differs in database and in runtime environment";

void mekanoInit(void)
{
  if (hash) return;

  hash = new eyedb::GenHashTable(0, 135);

  Root_init_p();
  Bank_init_p();
  Clone_init_p();
  Read_init_p();
  Sequence_init_p();
  ReadPosition_init_p();
  ContinuousSequence_init_p();
  Contig_init_p();
  Cut_init_p();
  Metacontig_init_p();
  Region_init_p();
  LinkCount_init_p();
  LinkCounts_init_p();
  Supercontig_init_p();
  SupercontigPair_init_p();
  Calculated_init_p();
  Parameters_init_p();
  GroupName_init_p();
  SupercontigSet_init_p();
  Group_init_p();
  StageType_init_p();
  Stage_init_p();
  Algorithm_init_p();
  MatchSide_init_p();
  Match_init_p();
  bag_class_SupercontigPair_init_p();
  array_class_bag_class_SupercontigPair_ref_init_p();
  set_class_Supercontig_ref_init_p();
  array_class_SupercontigSet_ref_init_p();
  Root_init();
  Bank_init();
  Clone_init();
  Read_init();
  Sequence_init();
  ReadPosition_init();
  ContinuousSequence_init();
  Contig_init();
  Cut_init();
  Metacontig_init();
  Region_init();
  LinkCount_init();
  LinkCounts_init();
  Supercontig_init();
  SupercontigPair_init();
  Calculated_init();
  Parameters_init();
  GroupName_init();
  SupercontigSet_init();
  Group_init();
  StageType_init();
  Stage_init();
  Algorithm_init();
  MatchSide_init();
  Match_init();
}

void mekanoRelease(void)
{
  if (!hash) return;

  delete hash;
  hash = 0;

  Root_Class->release();
  Bank_Class->release();
  Clone_Class->release();
  Read_Class->release();
  Sequence_Class->release();
  ReadPosition_Class->release();
  ContinuousSequence_Class->release();
  Contig_Class->release();
  Cut_Class->release();
  Metacontig_Class->release();
  Region_Class->release();
  LinkCount_Class->release();
  LinkCounts_Class->release();
  Supercontig_Class->release();
  SupercontigPair_Class->release();
  Calculated_Class->release();
  Parameters_Class->release();
  GroupName_Class->release();
  SupercontigSet_Class->release();
  Group_Class->release();
  StageType_Class->release();
  Stage_Class->release();
  Algorithm_Class->release();
  MatchSide_Class->release();
  Match_Class->release();
  bag_class_SupercontigPair_Class->release();
  array_class_bag_class_SupercontigPair_ref_Class->release();
  set_class_Supercontig_ref_Class->release();
  array_class_SupercontigSet_ref_Class->release();
}

static eyedb::Status
mekanoSchemaUpdate(eyedb::Schema *m, eyedb::Database *db)
{
  m->setName("mekano");
  eyedb::Status status;
  eyedb::StructClass *Root_class = Root_make(0, m);
  eyedb::StructClass *Bank_class = Bank_make(0, m);
  if (!m->getClass("Bank"))
    {
      status = m->addClass(Bank_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Clone_class = Clone_make(0, m);
  if (!m->getClass("Clone"))
    {
      status = m->addClass(Clone_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Read_class = Read_make(0, m);
  if (!m->getClass("Read"))
    {
      status = m->addClass(Read_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Sequence_class = Sequence_make(0, m);
  if (!m->getClass("Sequence"))
    {
      status = m->addClass(Sequence_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ReadPosition_class = ReadPosition_make(0, m);
  if (!m->getClass("ReadPosition"))
    {
      status = m->addClass(ReadPosition_class);
      if (status)
        return status;
    }
  eyedb::StructClass *ContinuousSequence_class = ContinuousSequence_make(0, m);
  if (!m->getClass("ContinuousSequence"))
    {
      status = m->addClass(ContinuousSequence_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Contig_class = Contig_make(0, m);
  if (!m->getClass("Contig"))
    {
      status = m->addClass(Contig_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Cut_class = Cut_make(0, m);
  if (!m->getClass("Cut"))
    {
      status = m->addClass(Cut_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Metacontig_class = Metacontig_make(0, m);
  if (!m->getClass("Metacontig"))
    {
      status = m->addClass(Metacontig_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Region_class = Region_make(0, m);
  if (!m->getClass("Region"))
    {
      status = m->addClass(Region_class);
      if (status)
        return status;
    }
  eyedb::StructClass *LinkCount_class = LinkCount_make(0, m);
  if (!m->getClass("LinkCount"))
    {
      status = m->addClass(LinkCount_class);
      if (status)
        return status;
    }
  eyedb::StructClass *LinkCounts_class = LinkCounts_make(0, m);
  if (!m->getClass("LinkCounts"))
    {
      status = m->addClass(LinkCounts_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Supercontig_class = Supercontig_make(0, m);
  if (!m->getClass("Supercontig"))
    {
      status = m->addClass(Supercontig_class);
      if (status)
        return status;
    }
  eyedb::StructClass *SupercontigPair_class = SupercontigPair_make(0, m);
  if (!m->getClass("SupercontigPair"))
    {
      status = m->addClass(SupercontigPair_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Calculated_class = Calculated_make(0, m);
  if (!m->getClass("Calculated"))
    {
      status = m->addClass(Calculated_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Parameters_class = Parameters_make(0, m);
  if (!m->getClass("Parameters"))
    {
      status = m->addClass(Parameters_class);
      if (status)
        return status;
    }
  eyedb::StructClass *GroupName_class = GroupName_make(0, m);
  if (!m->getClass("GroupName"))
    {
      status = m->addClass(GroupName_class);
      if (status)
        return status;
    }
  eyedb::StructClass *SupercontigSet_class = SupercontigSet_make(0, m);
  if (!m->getClass("SupercontigSet"))
    {
      status = m->addClass(SupercontigSet_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Group_class = Group_make(0, m);
  if (!m->getClass("Group"))
    {
      status = m->addClass(Group_class);
      if (status)
        return status;
    }
  eyedb::StructClass *StageType_class = StageType_make(0, m);
  if (!m->getClass("StageType"))
    {
      status = m->addClass(StageType_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Stage_class = Stage_make(0, m);
  if (!m->getClass("Stage"))
    {
      status = m->addClass(Stage_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Algorithm_class = Algorithm_make(0, m);
  if (!m->getClass("Algorithm"))
    {
      status = m->addClass(Algorithm_class);
      if (status)
        return status;
    }
  eyedb::StructClass *MatchSide_class = MatchSide_make(0, m);
  if (!m->getClass("MatchSide"))
    {
      status = m->addClass(MatchSide_class);
      if (status)
        return status;
    }
  eyedb::StructClass *Match_class = Match_make(0, m);
  if (!m->getClass("Match"))
    {
      status = m->addClass(Match_class);
      if (status)
        return status;
    }
  eyedb::CollBagClass *bag_class_SupercontigPair_class = bag_class_SupercontigPair_make(0, m);
  if (!m->getClass("bag<SupercontigPair>"))
    {
      status = m->addClass(bag_class_SupercontigPair_class);
      if (status)
        return status;
    }
  eyedb::CollArrayClass *array_class_bag_class_SupercontigPair_ref_class = array_class_bag_class_SupercontigPair_ref_make(0, m);
  if (!m->getClass("array<bag<SupercontigPair>*>"))
    {
      status = m->addClass(array_class_bag_class_SupercontigPair_ref_class);
      if (status)
        return status;
    }
  eyedb::CollSetClass *set_class_Supercontig_ref_class = set_class_Supercontig_ref_make(0, m);
  if (!m->getClass("set<Supercontig*>"))
    {
      status = m->addClass(set_class_Supercontig_ref_class);
      if (status)
        return status;
    }
  eyedb::CollArrayClass *array_class_SupercontigSet_ref_class = array_class_SupercontigSet_ref_make(0, m);
  if (!m->getClass("array<SupercontigSet*>"))
    {
      status = m->addClass(array_class_SupercontigSet_ref_class);
      if (status)
        return status;
    }

  Root_make(Root_class, m);
  Bank_make(Bank_class, m);
  Clone_make(Clone_class, m);
  Read_make(Read_class, m);
  Sequence_make(Sequence_class, m);
  ReadPosition_make(ReadPosition_class, m);
  ContinuousSequence_make(ContinuousSequence_class, m);
  Contig_make(Contig_class, m);
  Cut_make(Cut_class, m);
  Metacontig_make(Metacontig_class, m);
  Region_make(Region_class, m);
  LinkCount_make(LinkCount_class, m);
  LinkCounts_make(LinkCounts_class, m);
  Supercontig_make(Supercontig_class, m);
  SupercontigPair_make(SupercontigPair_class, m);
  Calculated_make(Calculated_class, m);
  Parameters_make(Parameters_class, m);
  GroupName_make(GroupName_class, m);
  SupercontigSet_make(SupercontigSet_class, m);
  Group_make(Group_class, m);
  StageType_make(StageType_class, m);
  Stage_make(Stage_class, m);
  Algorithm_make(Algorithm_class, m);
  MatchSide_make(MatchSide_class, m);
  Match_make(Match_class, m);

  if (!db) return eyedb::Success;

  if (!Bank_class->compare(m->getClass("Bank")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Bank' %s", differ_msg);
  if (!Clone_class->compare(m->getClass("Clone")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Clone' %s", differ_msg);
  if (!Read_class->compare(m->getClass("Read")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Read' %s", differ_msg);
  if (!Sequence_class->compare(m->getClass("Sequence")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Sequence' %s", differ_msg);
  if (!ReadPosition_class->compare(m->getClass("ReadPosition")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ReadPosition' %s", differ_msg);
  if (!ContinuousSequence_class->compare(m->getClass("ContinuousSequence")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'ContinuousSequence' %s", differ_msg);
  if (!Contig_class->compare(m->getClass("Contig")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Contig' %s", differ_msg);
  if (!Cut_class->compare(m->getClass("Cut")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Cut' %s", differ_msg);
  if (!Metacontig_class->compare(m->getClass("Metacontig")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Metacontig' %s", differ_msg);
  if (!Region_class->compare(m->getClass("Region")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Region' %s", differ_msg);
  if (!LinkCount_class->compare(m->getClass("LinkCount")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'LinkCount' %s", differ_msg);
  if (!LinkCounts_class->compare(m->getClass("LinkCounts")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'LinkCounts' %s", differ_msg);
  if (!Supercontig_class->compare(m->getClass("Supercontig")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Supercontig' %s", differ_msg);
  if (!SupercontigPair_class->compare(m->getClass("SupercontigPair")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'SupercontigPair' %s", differ_msg);
  if (!Calculated_class->compare(m->getClass("Calculated")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Calculated' %s", differ_msg);
  if (!Parameters_class->compare(m->getClass("Parameters")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Parameters' %s", differ_msg);
  if (!GroupName_class->compare(m->getClass("GroupName")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'GroupName' %s", differ_msg);
  if (!SupercontigSet_class->compare(m->getClass("SupercontigSet")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'SupercontigSet' %s", differ_msg);
  if (!Group_class->compare(m->getClass("Group")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Group' %s", differ_msg);
  if (!StageType_class->compare(m->getClass("StageType")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'StageType' %s", differ_msg);
  if (!Stage_class->compare(m->getClass("Stage")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Stage' %s", differ_msg);
  if (!Algorithm_class->compare(m->getClass("Algorithm")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Algorithm' %s", differ_msg);
  if (!MatchSide_class->compare(m->getClass("MatchSide")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'MatchSide' %s", differ_msg);
  if (!Match_class->compare(m->getClass("Match")))
    return eyedb::Exception::make(eyedb::IDB_ERROR, "'Match' %s", differ_msg);

  db->transactionBegin();

  if ((status = Root_attrcomp_realize(db, m->getClass("Root")))) return status;

  if ((status = Bank_attrcomp_realize(db, m->getClass("Bank")))) return status;

  if ((status = Clone_attrcomp_realize(db, m->getClass("Clone")))) return status;

  if ((status = Read_attrcomp_realize(db, m->getClass("Read")))) return status;

  if ((status = Sequence_attrcomp_realize(db, m->getClass("Sequence")))) return status;

  if ((status = ReadPosition_attrcomp_realize(db, m->getClass("ReadPosition")))) return status;

  if ((status = ContinuousSequence_attrcomp_realize(db, m->getClass("ContinuousSequence")))) return status;

  if ((status = Contig_attrcomp_realize(db, m->getClass("Contig")))) return status;

  if ((status = Cut_attrcomp_realize(db, m->getClass("Cut")))) return status;

  if ((status = Metacontig_attrcomp_realize(db, m->getClass("Metacontig")))) return status;

  if ((status = Region_attrcomp_realize(db, m->getClass("Region")))) return status;

  if ((status = LinkCount_attrcomp_realize(db, m->getClass("LinkCount")))) return status;

  if ((status = LinkCounts_attrcomp_realize(db, m->getClass("LinkCounts")))) return status;

  if ((status = Supercontig_attrcomp_realize(db, m->getClass("Supercontig")))) return status;

  if ((status = SupercontigPair_attrcomp_realize(db, m->getClass("SupercontigPair")))) return status;

  if ((status = Calculated_attrcomp_realize(db, m->getClass("Calculated")))) return status;

  if ((status = Parameters_attrcomp_realize(db, m->getClass("Parameters")))) return status;

  if ((status = GroupName_attrcomp_realize(db, m->getClass("GroupName")))) return status;

  if ((status = SupercontigSet_attrcomp_realize(db, m->getClass("SupercontigSet")))) return status;

  if ((status = Group_attrcomp_realize(db, m->getClass("Group")))) return status;

  if ((status = StageType_attrcomp_realize(db, m->getClass("StageType")))) return status;

  if ((status = Stage_attrcomp_realize(db, m->getClass("Stage")))) return status;

  if ((status = Algorithm_attrcomp_realize(db, m->getClass("Algorithm")))) return status;

  if ((status = MatchSide_attrcomp_realize(db, m->getClass("MatchSide")))) return status;

  if ((status = Match_attrcomp_realize(db, m->getClass("Match")))) return status;
  status = m->realize();
  if (status) return status;
  db->transactionCommit();
  return eyedb::Success;
}

eyedb::Status mekanoSchemaUpdate(eyedb::Database *db)
{
  return mekanoSchemaUpdate(db->getSchema(), db);
}

eyedb::Status mekanoSchemaUpdate(eyedb::Schema *m)
{
  return mekanoSchemaUpdate(m, NULL);
}

eyedb::Object *mekanoMakeObject(eyedb::Object *o, eyedb::Bool remove)
{
  if (!o->getClass()) return (eyedb::Object *)0;
  if (eyedb::ObjectPeer::isGRTObject(o))
    return o;
  int ind = hash->get(o->getClass()->getName());
  if (ind < 0 && (!o->getClass()->getStrictAliasName() || (ind = hash->get(o->getClass()->getStrictAliasName())) < 0)) return 0;
  eyedb::Object *co = constructors[ind](o, (remove ? eyedb::True : eyedb::False));
  eyedb::ObjectPeer::setClass(co, o->getClass());
  if (remove) o->release();
  if (co->getDatabase())
    co->getDatabase()->cacheObject(co);
  return co;
}

mekanoDatabase::mekanoDatabase(eyedb::Connection *conn, const char *dbname, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth) : eyedb::Database(dbname)
{
  eyedb::Status status = open(conn, flag, 0, userauth, passwdauth);
  if (status) throw *status;
}

mekanoDatabase::mekanoDatabase(eyedb::Connection *conn, const char *dbname, const char *dbmdb_str, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth) : eyedb::Database(dbname, dbmdb_str)
{
  eyedb::Status status = open(conn, flag, 0, userauth, passwdauth);
  if (status) throw *status;
}

eyedb::Status mekanoDatabase::open(eyedb::Connection *conn, eyedb::Database::OpenFlag flag, const char *userauth, const char *passwdauth)
{
  return open(conn, flag, 0, userauth, passwdauth);
}

eyedb::Status mekanoDatabase::open(eyedb::Connection *conn, eyedb::Database::OpenFlag flag, const eyedb::OpenHints *hints, const char *userauth, const char *passwdauth)
{
  eyedb::Status status = eyedb::Database::open(conn, flag, hints, userauth, passwdauth);
  if (status) return status;
  transactionBegin();
  status = mekanoDatabase::checkSchema(getSchema());
  transactionCommit();

  if (!status) add(hash, constructors_x);

  return status;
}

void mekanoDatabase::setConsApp(eyedb::Database *_db)
{
  _db->add(hash, constructors_x);
}

Root *mekanoDatabase::asRoot(eyedb::Object *o)
{
  if (!eyedb::ObjectPeer::isGRTObject(o))
     return (Root *)make_object(o, eyedb::False);

  if (hash->get(o->getClass()->getName()) < 0)
     return (Root *)0;

  return (Root *)o;
}

const Root *mekanoDatabase::asRoot(const eyedb::Object *o)
{
  if (!eyedb::ObjectPeer::isGRTObject((eyedb::Object *)o))
    return (const Root *)make_object((eyedb::Object *)o, eyedb::False);

  if (hash->get(o->getClass()->getName()) < 0)
    return (const Root *)0;

  return (const Root *)o;
}

static void append(char *&s, const char *m1, const char *m2)
{
  if (!s) {s = (char *)malloc(strlen(m1)+strlen(m2)+2); *s = 0;}
  else s = (char *)realloc(s, strlen(s)+strlen(m1)+strlen(m2)+2);
  strcat(s, m1);
  strcat(s, m2);
  strcat(s, "\n");
}

eyedb::Bool mekanoDatabase::getDynamicGetErrorPolicy() {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "getDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

eyedb::Bool mekanoDatabase::getDynamicSetErrorPolicy() {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "getDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void mekanoDatabase::setDynamicGetErrorPolicy(eyedb::Bool policy) {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "setDynamicGetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

void mekanoDatabase::setDynamicSetErrorPolicy(eyedb::Bool policy) {
   throw *eyedb::Exception::make(eyedb::IDB_ERROR, "setDynamicSetErrorPolicy() can be called only when the dynamic attribute fonctionnality is on (-dynamic-attr option of eyedbodl)");
}

eyedb::Status mekanoDatabase::checkSchema(eyedb::Schema *m)
{
  eyedb::Class *cl;
  char *s = 0;

  if (!(cl = m->getClass("Bank")))
    append(s, "'Bank' ", not_exit_msg);
  else if (!Bank_Class->compare(cl))
    append(s, "'Bank' ", differ_msg);
  if (!(cl = m->getClass("Clone")))
    append(s, "'Clone' ", not_exit_msg);
  else if (!Clone_Class->compare(cl))
    append(s, "'Clone' ", differ_msg);
  if (!(cl = m->getClass("Read")))
    append(s, "'Read' ", not_exit_msg);
  else if (!Read_Class->compare(cl))
    append(s, "'Read' ", differ_msg);
  if (!(cl = m->getClass("Sequence")))
    append(s, "'Sequence' ", not_exit_msg);
  else if (!Sequence_Class->compare(cl))
    append(s, "'Sequence' ", differ_msg);
  if (!(cl = m->getClass("ReadPosition")))
    append(s, "'ReadPosition' ", not_exit_msg);
  else if (!ReadPosition_Class->compare(cl))
    append(s, "'ReadPosition' ", differ_msg);
  if (!(cl = m->getClass("ContinuousSequence")))
    append(s, "'ContinuousSequence' ", not_exit_msg);
  else if (!ContinuousSequence_Class->compare(cl))
    append(s, "'ContinuousSequence' ", differ_msg);
  if (!(cl = m->getClass("Contig")))
    append(s, "'Contig' ", not_exit_msg);
  else if (!Contig_Class->compare(cl))
    append(s, "'Contig' ", differ_msg);
  if (!(cl = m->getClass("Cut")))
    append(s, "'Cut' ", not_exit_msg);
  else if (!Cut_Class->compare(cl))
    append(s, "'Cut' ", differ_msg);
  if (!(cl = m->getClass("Metacontig")))
    append(s, "'Metacontig' ", not_exit_msg);
  else if (!Metacontig_Class->compare(cl))
    append(s, "'Metacontig' ", differ_msg);
  if (!(cl = m->getClass("Region")))
    append(s, "'Region' ", not_exit_msg);
  else if (!Region_Class->compare(cl))
    append(s, "'Region' ", differ_msg);
  if (!(cl = m->getClass("LinkCount")))
    append(s, "'LinkCount' ", not_exit_msg);
  else if (!LinkCount_Class->compare(cl))
    append(s, "'LinkCount' ", differ_msg);
  if (!(cl = m->getClass("LinkCounts")))
    append(s, "'LinkCounts' ", not_exit_msg);
  else if (!LinkCounts_Class->compare(cl))
    append(s, "'LinkCounts' ", differ_msg);
  if (!(cl = m->getClass("Supercontig")))
    append(s, "'Supercontig' ", not_exit_msg);
  else if (!Supercontig_Class->compare(cl))
    append(s, "'Supercontig' ", differ_msg);
  if (!(cl = m->getClass("SupercontigPair")))
    append(s, "'SupercontigPair' ", not_exit_msg);
  else if (!SupercontigPair_Class->compare(cl))
    append(s, "'SupercontigPair' ", differ_msg);
  if (!(cl = m->getClass("Calculated")))
    append(s, "'Calculated' ", not_exit_msg);
  else if (!Calculated_Class->compare(cl))
    append(s, "'Calculated' ", differ_msg);
  if (!(cl = m->getClass("Parameters")))
    append(s, "'Parameters' ", not_exit_msg);
  else if (!Parameters_Class->compare(cl))
    append(s, "'Parameters' ", differ_msg);
  if (!(cl = m->getClass("GroupName")))
    append(s, "'GroupName' ", not_exit_msg);
  else if (!GroupName_Class->compare(cl))
    append(s, "'GroupName' ", differ_msg);
  if (!(cl = m->getClass("SupercontigSet")))
    append(s, "'SupercontigSet' ", not_exit_msg);
  else if (!SupercontigSet_Class->compare(cl))
    append(s, "'SupercontigSet' ", differ_msg);
  if (!(cl = m->getClass("Group")))
    append(s, "'Group' ", not_exit_msg);
  else if (!Group_Class->compare(cl))
    append(s, "'Group' ", differ_msg);
  if (!(cl = m->getClass("StageType")))
    append(s, "'StageType' ", not_exit_msg);
  else if (!StageType_Class->compare(cl))
    append(s, "'StageType' ", differ_msg);
  if (!(cl = m->getClass("Stage")))
    append(s, "'Stage' ", not_exit_msg);
  else if (!Stage_Class->compare(cl))
    append(s, "'Stage' ", differ_msg);
  if (!(cl = m->getClass("Algorithm")))
    append(s, "'Algorithm' ", not_exit_msg);
  else if (!Algorithm_Class->compare(cl))
    append(s, "'Algorithm' ", differ_msg);
  if (!(cl = m->getClass("MatchSide")))
    append(s, "'MatchSide' ", not_exit_msg);
  else if (!MatchSide_Class->compare(cl))
    append(s, "'MatchSide' ", differ_msg);
  if (!(cl = m->getClass("Match")))
    append(s, "'Match' ", not_exit_msg);
  else if (!Match_Class->compare(cl))
    append(s, "'Match' ", differ_msg);
  if (s) {eyedb::Status status = eyedb::Exception::make(s); free(s); return status;}
  return eyedb::Success;
}

eyedb::Bool mekano_set_oid_check(eyedb::Bool _oid_check)
{
  eyedb::Bool old = oid_check;
  oid_check = _oid_check;
  return old;
}

eyedb::Bool mekano_get_oid_check()
{
  return oid_check;
}

}
